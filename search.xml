<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cpp的一些总结</title>
      <link href="2021/02/07/cpp-de-yi-xie-zong-jie/"/>
      <url>2021/02/07/cpp-de-yi-xie-zong-jie/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python simple review</title>
      <link href="2020/11/01/python-simple-review/"/>
      <url>2020/11/01/python-simple-review/</url>
      
        <content type="html"><![CDATA[<h2 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h2><p>简单复习下py的知识,方便忘记了语法的时候进行查阅</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>str() 强制把括号里的内容转换为字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name<span class="token operator">=</span><span class="token triple-quoted-string string">'''hello,everyon my name is json,how are you these days'''</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#第一个参数是起始字符,第二个参数是结束字符的位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">first <span class="token operator">=</span> <span class="token string">"Smith"</span>last <span class="token operator">=</span> <span class="token string">"wang"</span>msg <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>first<span class="token punctuation">}</span></span><span class="token string">  [</span><span class="token interpolation"><span class="token punctuation">{</span>last<span class="token punctuation">}</span></span><span class="token string">] is a  manager!'</span></span> <span class="token comment">#格式化字符串就是在整个字符串前加f ,然后把变量用{}包围起来</span><span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#字符串内置的一些函数的使用</span>course <span class="token operator">=</span> <span class="token string">"Python for beginers"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>course<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>course<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>course<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>course<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'be'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>course<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'for'</span><span class="token punctuation">,</span><span class="token string">'while'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hh'</span><span class="token keyword">in</span> course<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 逻辑运算符有and or not</span>is_hot <span class="token operator">=</span> <span class="token boolean">True</span>is_cold <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">if</span> is_hot <span class="token keyword">and</span> is_cold<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"nice day"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"so bad "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#for循环的语法</span><span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token string">'python'</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#列表的num1:num2 代表选择列表中的左闭右开</span>name <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Wamg"</span><span class="token punctuation">,</span> <span class="token string">"sun"</span><span class="token punctuation">,</span> <span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token string">"zhao"</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#这个就代表[0,3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>list 中存在的方法:<br><a href="http://www.python-ds.com/python-3-list-methods">链接</a></p><p>平时把list当作容器用就行了</p><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#这是元组,主要特性就是不可以增加/删除/修改元组里的东西</span>tuple1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">51</span><span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>tuple1<span class="token punctuation">)</span><span class="token punctuation">)</span>tuple1<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">54</span><span class="token punctuation">,</span><span class="token number">51</span><span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token operator">=</span>tuple1<span class="token comment">#这种复制方法很方便,也同样适合于列表</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dic"><a href="#dic" class="headerlink" title="dic"></a>dic</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"laowang"</span><span class="token punctuation">,</span>    <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">34</span><span class="token punctuation">,</span>    <span class="token string">"sex"</span><span class="token punctuation">:</span> <span class="token string">"man"</span><span class="token punctuation">,</span>    <span class="token string">"qq"</span><span class="token punctuation">:</span> <span class="token string">"1248597254"</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>dic1<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"tq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">#得到字典中的值不会报错的方式</span>dic1<span class="token punctuation">[</span><span class="token string">"sex"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"woman"</span>  <span class="token comment"># 修改字典的某个值</span>dic1<span class="token punctuation">[</span><span class="token string">"tel"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"4816322"</span>  <span class="token comment"># 在字典中添加新项目</span><span class="token keyword">print</span><span class="token punctuation">(</span>dic1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#函数的定义方法</span><span class="token keyword">def</span> <span class="token function">greet_user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is a function"</span><span class="token punctuation">)</span>greet_user<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">#函数的调用</span><span class="token comment">#带有参数的</span><span class="token keyword">def</span> <span class="token function">greet_user</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Hello </span><span class="token interpolation"><span class="token punctuation">{</span>first<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span>last<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>greet_user<span class="token punctuation">(</span><span class="token string">"simth"</span><span class="token punctuation">,</span> <span class="token string">"Tomes"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#异常的处理,try检测可能有异常的代码块,except表明异常的类型,然后定义发生了这种异常后的处理方式,最后的退出代码是0,代表正常退出程序</span><span class="token keyword">try</span><span class="token punctuation">:</span>    age<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"what's your age "</span><span class="token punctuation">)</span>    age<span class="token operator">+=</span><span class="token number">3</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"your type is error"</span><span class="token punctuation">)</span><span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"your input is not valid"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#类的创建方法和怎么实例化一个对象,直接用等号的方式就可以了__init__()是构造函数</span><span class="token keyword">class</span> <span class="token class-name">person1</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"wang"</span>        self<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">3</span>    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>age<span class="token punctuation">)</span>demo1 <span class="token operator">=</span> person1<span class="token punctuation">(</span><span class="token punctuation">)</span>demo1<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#类的继承</span><span class="token keyword">class</span> <span class="token class-name">animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">bird</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>demo <span class="token operator">=</span> bird<span class="token punctuation">(</span><span class="token string">"燕子"</span><span class="token punctuation">)</span>demo<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#模块的倒入,模块就是一个py代码的集合文件</span><span class="token keyword">import</span> masterdemo <span class="token operator">=</span> master<span class="token punctuation">.</span>bird<span class="token punctuation">(</span><span class="token string">" 燕子 "</span><span class="token punctuation">)</span>demo<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.python.org/3/py-modindex.html">python3模块索引</a></p><h2 id="furture"><a href="#furture" class="headerlink" title="furture"></a>furture</h2><p>之后的事情就是根据文档来学习一些框架,来部署一些应用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编辑时的一些快捷键</title>
      <link href="2020/10/30/shell-bian-ji-shi-de-yi-xie-kuai-jie-jian/"/>
      <url>2020/10/30/shell-bian-ji-shi-de-yi-xie-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#光标的移动</span>Ctrl + b：同键盘左键，向左移动光标。Ctrl + f：同键盘右键，向右移动光标。Alt + b：向前移动一个词的距离。如果shell终端配置启用了可以通过快捷键打开菜单，会发生冲突，解决办法是禁用这个功能或者和Shift键一起使用。Alt + f：向后移动一个词的距离。如果shell终端配置启用了可以通过快捷键打开菜单，会发生冲突，解决办法是禁用这个功能或者和Shift键一起使用。Esc + b：移动到当前单词的开头。Esc + f：移动到当前单词的结尾。Ctrl + a：移动光标到命令行首。Ctrl + e：移动光标到命令行尾。Ctrl + x + x：光标在命令行中光标最后两次出现的位置间进行切换<span class="token comment">#删除</span>Ctrl + h：同Backspace，退格向左删除。Ctrl + d：同delete，向右删除。Ctrl + w：剪切光标之前的一个词。Alt + d：剪切光标之后的一个词。Ctrl + u：从当前光标所在位置向左剪切全部命令。Ctrl + k：从当前光标所在位置向右剪切全部命令。<span class="token comment">#替换</span>Alt + u：从当前字符开始的一个字符串，字母替换为大写。Alt + l：从当前字符开始的一个字符串，字母替换为小写。Alt + c：当前字符变为大写，向后的一个字符串全部变为小写。Ctrl + t：交换光标前的最后两个字符。Alt + t：交换当前单词和前一个单词的位置。如果shell终端配置启用了可以通过快捷键打开菜单，会发生冲突，解决办法是禁用这个功能或者和Shift键一起使用。Esc + t：交换光标前的最后两个单词。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoldenDic字典的安装</title>
      <link href="2020/10/07/goldendic-zi-dian-de-an-zhuang/"/>
      <url>2020/10/07/goldendic-zi-dian-de-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="GoldenDic字典的安装以及使用"><a href="#GoldenDic字典的安装以及使用" class="headerlink" title="GoldenDic字典的安装以及使用"></a>GoldenDic字典的安装以及使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要好好学习下英语了,所以考虑下遇到自己不会的单词时怎么办,在Arch群里水群时,和群友交流发现这个字典比较好用,以前使用的是谷歌翻译的点按翻译(在其他应用里不能进行翻译就很不舒服)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S goldendict<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="字典的获取以及安装"><a href="#字典的获取以及安装" class="headerlink" title="字典的获取以及安装"></a>字典的获取以及安装</h2><h3 id="本地字典"><a href="#本地字典" class="headerlink" title="本地字典"></a>本地字典</h3><p><strong>下载地址</strong></p><p><a href="http://download.huzheng.org/zh_CN/">http://download.huzheng.org/zh_CN/</a></p><p><a href="https://github.com/skywind3000/ECDICT/releases/tag/1.0.28">https://github.com/skywind3000/ECDICT/releases/tag/1.0.28</a></p><p><strong>载入方法</strong></p><p>随便建立一个目录</p><p>把字典文件解压到刚才建立的文件夹中</p><ol><li>打开字典软件</li><li>编辑–字典–字典来源 </li><li>选择刚才建立的目录,钩上递归搜索</li></ol><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20201007102918347.png"></p><h3 id="使用谷歌翻译整个句子"><a href="#使用谷歌翻译整个句子" class="headerlink" title="使用谷歌翻译整个句子"></a>使用谷歌翻译整个句子</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>如果是Arch,推介直接pacman -S translate-shell</p><p>其他发行版的话</p><ul><li><p>下载<a href="https://github.com/soimort/translate-shell">Translator shell</a></p></li><li><p>编译安装</p><pre class="line-numbers language-none"><code class="language-none">make sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">编译--<span class="token operator">&gt;</span>词典--<span class="token operator">&gt;</span>程序--<span class="token operator">&gt;</span>添加类型: 纯文本名称: google命令: trans -e google -s en -t zh-CN -show-original y -show-original-phonetics n -show-translation y -no-ansi -show-translation-phonetics n -show-prompt-message n -show-languages y -show-original-dictionary n -show-dictionary n -show-alternatives n <span class="token string">"%GDWORD%"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="点按翻译的使用"><a href="#点按翻译的使用" class="headerlink" title="点按翻译的使用"></a>点按翻译的使用</h2><p>编辑–首选项 </p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20201007103721338.png"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20201007103744865.png"></p><p>按照我这样设置,在其他应用中 ctrl+C+C 就可选词翻译,因为用了谷歌翻译,所以也可直接翻译整个句子</p><p>这估计会是我学习英语的一大助力</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vps再次折腾</title>
      <link href="2020/10/07/vps-zai-ci-zhe-teng/"/>
      <url>2020/10/07/vps-zai-ci-zhe-teng/</url>
      
        <content type="html"><![CDATA[<h1 id="又一次进行的尝试"><a href="#又一次进行的尝试" class="headerlink" title="又一次进行的尝试"></a>又一次进行的尝试</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>发现自己是有教育邮箱的,也就是昨天吧,突然就研究起了怎么用自己的教育邮箱进行科学上网,我目前发现的方法总结成以下的图表</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/%E6%96%B9%E6%A1%88%E7%BD%97%E5%88%971.png"></p><h2 id="heroku-CF这种方法"><a href="#heroku-CF这种方法" class="headerlink" title="heroku+CF这种方法"></a>heroku+CF这种方法</h2><p>这里参考了这篇<a href="https://www.skxlz.top/2020/07/26/25/">博客</a></p><h3 id="hroku的设置"><a href="#hroku的设置" class="headerlink" title="hroku的设置"></a>hroku的设置</h3><ol><li><a href="https://www.heroku.com/">注册Heroku账户</a></li></ol><p>注意：请使用外网IP注册，且请准备好翻译工具，并在收到邮件后激活账户；注册时不能使用QQ邮箱</p><ol start="2"><li><a href="https://dashboard.heroku.com/new?template=https://github.com/bclswl0827/v2ray-heroku">点击部署V2Ray</a></li></ol><p>数据中心就是你的服务器地址，谨慎选择；名称就是你的二级域名前缀，如果出现红色说明该名称不可用，多换几个就好；然后点击<code>Deploy app</code>系统会自动部署</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/yuwSI3ZDH2Al1zv.png" alt="1.png"></p><ol start="3"><li>稍微等待一会儿，几秒的样子，直到全部打勾变绿</li></ol><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/fd57AHMpIRzcjVS.png" alt="_QDSTESMS7_O0J_NW@EPTAY.png"></p><ol start="4"><li><a href="https://dashboard.heroku.com/apps">点击进入你的项目</a></li></ol><p>注意：你会看到一个项目，点击上方的Settings进入，查看你的V2Ray具体配置，如图</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/7JFduiOGqoAkfwv.png" alt="5WX8E66XLEB3@LR~ZSZE_FI.png"></p><ol start="5"><li>点击Reveal Config Vars显示V2RrayN相关配置信息，如图</li></ol><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/4PkEfC9JbWz1hZ2.png" alt="skacxfnu.png"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/eJ5CXcOkRKs2oD3.png" alt="zjxnhcfu.png"></p><ol start="6"><li>开始配置V2Ray，如果你记好了以上两个（一串字母和二级网域）</li></ol><p>__注意:__二级网域不用加<code>https://</code>，直接填域名就好</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/xI6y8TYWHjoJftp.png" alt="csxkmfj.png"></p><ol start="7"><li>完成，接下来要是不会使用V2Ray请自裁</li></ol><h3 id="CF反向代理的设置"><a href="#CF反向代理的设置" class="headerlink" title="CF反向代理的设置"></a>CF反向代理的设置</h3><ol><li>在<a href="https://dash.cloudflare.com/">Cloudflare Workers</a>中创建一个Workers</li></ol><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/a3hNf65UD2rsGYT.png" alt="1.png"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/ZsGLCQNhjYlzgap.png" alt="2.png">2.  将原有的示例代码全部删除，复制如下代码，并将第四行的汉字替换为你的V2Ray的地址</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">addEventListener(  <span class="token string">"fetch"</span><span class="token punctuation">,</span>event =&gt; <span class="token punctuation">{</span>     let url=new URL(event.request.url);     url.hostname=<span class="token string">"需要反代的 V2Ray 服务器地址"</span>; <span class="token comment">//这里反代的是二级域名,不需要加https</span>     let request=new Request(url<span class="token punctuation">,</span>event.request);     event. respondWith(       fetch(request)     ) <span class="token punctuation">}</span>)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>点击右侧的<code>发送</code>按钮，看最后一行是否出现了<code>Bad Request</code>，出现则代表成功</li></ol><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/Qsd43hIbvXUFYLi.png" alt="3.png"><em>第二、三两步的示范图</em></p><ol><li>成功后，点击<code>保存并部署</code>，并记下你的Workers二级域名</li><li>其实到第四步已经可以了，把V2Ray中原来的域名改为现在的Workers域名就行了，但是毕竟会有人追求极致完美嘛</li></ol><p><strong>对速度有更高追求以及不怕折腾的人可以接着往下看</strong></p><h4 id="对Cloudflare节点的筛选"><a href="#对Cloudflare节点的筛选" class="headerlink" title="对Cloudflare节点的筛选"></a>对Cloudflare节点的筛选</h4><p>点击下载<a href="https://proxy.freecdn.workers.dev/?url=https://raw.githubusercontent.com/badafans/better-cloudflare-ip/master/better-cloudflare-ip-win32.zip">IP自选程序</a>，解压，在Windows系统下运行 这是这个项目主页:<a href="https://github.com/badafans/better-cloudflare-ip">better-cloudflare-ip</a></p><p>如果确实帮到了你,请给作者点个星星吧</p><p>其他的<code>使用说明.txt</code>文件中都有说，在此就不过多赘述</p><p>最后，配置V2Ray：</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/cbnmyoiXAwDMVrE.png" alt="4.png"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于各地的网络情况每天都不同，所以每天（甚至是每半天）的最优节点都不尽相同；但对于一个应急用的已经足够了</p><h2 id="尝试下我的想法"><a href="#尝试下我的想法" class="headerlink" title="尝试下我的想法"></a>尝试下我的想法</h2><p>具体思路是:在自己小鸡上部署ws的传输协议,然后用cf反向代理我的网站</p><p>已经实现了,以后有空再写教程吧</p><p>QUQ 折腾这个又花了我一天时间,明天再学习QT吧</p><p>每次扫号好麻烦,要是能实现自动扫号,然后根据结果再直接生成订阅链接再自动更新就好了(可以考虑用容器实现下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> logs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake 简单学习记录</title>
      <link href="2020/09/13/cmake-jian-dan-xue-xi-ji-lu/"/>
      <url>2020/09/13/cmake-jian-dan-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p> cmake学习</p><h2 id="cmake的流程"><a href="#cmake的流程" class="headerlink" title="cmake的流程"></a>cmake的流程</h2><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200901203612929.png"></p><h2 id="cmake-包含不同文件时"><a href="#cmake-包含不同文件时" class="headerlink" title="cmake 包含不同文件时"></a>cmake 包含不同文件时</h2><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本教程看的是一个<a href="https://cliutils.gitlab.io/modern-cmake/chapters/intro/running.html">gitbook</a> </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">pacman -S cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="cmake的一般构建过程"><a href="#cmake的一般构建过程" class="headerlink" title="cmake的一般构建过程"></a>cmake的一般构建过程</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#在CMakeList.txt所在的目录</span><span class="token function">mkdir</span> build<span class="token builtin class-name">cd</span> buildcmake <span class="token punctuation">..</span><span class="token function">make</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新的cmake这么做</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cmake -S <span class="token builtin class-name">.</span> -B buildcmake --build build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#debug cmake</span>cmake --trace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在软件开发中，<strong>构建系统</strong>（<em>build system</em>）是用来从源代码生成用户可以使用的<strong>目标</strong>的<strong>自动化工具</strong>。目标可以包括库、可执行文件、或者生成的脚本等等。</p><p>构建目录呢，用于存储<strong>构建系统文件</strong>（比如makefile以及其他一些cmake相关配置文件）和<strong>构建输出文件</strong>（编译生成的中间文件、可执行程序、库）的顶级目录。</p><p><strong>set</strong>(CMAKE_CXX_STANDARD 17)</p><p>之前设置的<code>CMAKE_CXX_STANDARD</code>只是一个可选属性，如果编译器不支持此标准版本，则还是有可能会退化为以前的版本。如果我们想要明确表示需要某个<code>C++</code>标准，则可以通过：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_STANDARD_REQUIRED True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成器(generaor)</p><p>是为构建系统生成文件的工具</p><h2 id="从单个源文件到库"><a href="#从单个源文件到库" class="headerlink" title="从单个源文件到库"></a>从单个源文件到库</h2><h2 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.11</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span><span class="token string">"the single exe"</span><span class="token property">VERSION</span> <span class="token number">1.0.0</span>LANGUAGES CXX<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span> result  main.cpp <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cmake的语句不区分大小写,但是函数的参数区分</p><p>cmake是构建系统生成器</p><p>make用来构建项目</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">最终的可执行文件可以生成到任意目录cmake --build destination<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>cmake 里源文件的概念是CMAkeList.txt所在的目录,不是你所创建的文件夹的根目录</p><table><thead><tr><th>Variable</th><th>Info</th></tr></thead><tbody><tr><td>CMAKE_SOURCE_DIR</td><td>工程的顶级目录</td></tr><tr><td>CMAKE_CURRENT_SOURCE_DIR</td><td>CMakeLists.txt所在的目录</td></tr><tr><td>PROJECT_SOURCE_DIR</td><td>工程的顶级目录</td></tr><tr><td>CMAKE_CURRENT_LIST_DIR</td><td>CMakeLists.txt所在的目录</td></tr><tr><td>CMAKE_BINARY_DIR</td><td>如果是内部编译，就指的是工程的顶级目录，如果是外部编译，指的就是工程编译发生的目录</td></tr><tr><td>CMAKE_CURRENT_BINARY_DIR</td><td>外部编译时，指的是target目录，内部编译时，指的是顶级目录</td></tr><tr><td>PROJECT_BINARY_DIR</td><td>如果是内部编译，就指的是工程的顶级目录，如果是外部编译，指的就是工程编译发生的目录</td></tr></tbody></table><h2 id="具有类的文件"><a href="#具有类的文件" class="headerlink" title="具有类的文件"></a>具有类的文件</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#第一种方法</span><span class="token comment">#目录结构 头文件在一个文件夹中 main和其他cpp文件在头文件夹外边</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.11</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span><span class="token string">"study"</span><span class="token property">VERSION</span> <span class="token number">1.0.0</span>LANGUAGES CXX<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> main.cpp Message.cpp<span class="token punctuation">)</span><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span><span class="token namespace">PUBLIC</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/head<span class="token punctuation">)</span><span class="token comment">#第二种情况</span><span class="token comment">#文件目录 头文件和库放在一个文件夹里,用生成库的方式来比编译</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.11</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span><span class="token string">"study"</span><span class="token property">VERSION</span> <span class="token number">1.0.0</span>LANGUAGES CXX<span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span> main.cpp<span class="token punctuation">)</span><span class="token keyword">add_subdirectory</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token comment">#特别要注意这里,这里使用的第三个参数是库的名称,而不是一个目录.下边那个函数的第三个参数才使用的是目录(这个命令代表将库链接到可执行文件中</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span><span class="token namespace">PUBLIC</span>Message<span class="token punctuation">)</span><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span><span class="token namespace">PUBLIC</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/head<span class="token punctuation">)</span><span class="token comment"># 第三种情况 所有的文件都包含在一个目录中</span><span class="token comment">#这时的好处是不用添加那个include的文件夹</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.5</span> FATAL_ERROR<span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>recipe-<span class="token number">03</span> LANGUAGES CXX<span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span>message  <span class="token namespace">STATIC</span>    Message.hpp    Message.cpp  <span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello-world hello-world.cpp<span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>hello-world message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># 把第一个文件复制到第二个文件夹里的某个文件</span><span class="token keyword">configure_file</span><span class="token punctuation">(</span>        autoGeneratedHeaders/projectConfig.h.in       <span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span>/autoGeneratedHeaders/projectConfig.h <span class="token punctuation">)</span><span class="token comment">#添加包含的头文件</span><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>CMakeLearnDemo <span class="token namespace">PUBLIC</span>        autoGeneratedHeaders<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用条件语句控制编译"><a href="#用条件语句控制编译" class="headerlink" title="用条件语句控制编译"></a>用条件语句控制编译</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#这是关于流程控制部分的</span><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span> project-<span class="token number">4</span> LANGUAGES CXX  <span class="token property">VERSION</span> <span class="token number">1.0.0.1</span><span class="token punctuation">)</span><span class="token keyword">set</span> <span class="token punctuation">(</span> USE_LIBRARY <span class="token boolean">OFF</span> <span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span> STATUS <span class="token string">"Compile source into a library?"</span> <span class="token punctuation">${</span>USE_LIBRARY<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token keyword">set</span> <span class="token punctuation">(</span> <span class="token variable">BUILD_SHARED_LIBS</span> <span class="token boolean">OFF</span><span class="token punctuation">)</span><span class="token keyword">list</span> <span class="token punctuation">(</span>APPEND _source Message.cpp Message.h <span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>USE_LIBRARY<span class="token punctuation">)</span><span class="token keyword">add_library</span> <span class="token punctuation">(</span>message <span class="token punctuation">${</span>_source<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span> <span class="token punctuation">(</span>hello message<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>hello main.cpp <span class="token punctuation">${</span>_source<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">target_include_directories</span><span class="token punctuation">(</span>hello<span class="token namespace">PUBLIC</span><span class="token punctuation">${</span><span class="token variable">PROJECT_SOURCE_DIR</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#在构建的时候可以看自己编译器型号的,主要就是用了那几个变量</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Is the C++ compiler loaded? <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_COMPILER_LOADED</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_CXX_COMPILER_LOADED</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"The C++ compiler ID is: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_COMPILER_ID</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Is the C++ from GNU? <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_COMPILER_IS_GNUCXX</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"The C++ compiler version is: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_COMPILER_VERSION</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Is the C compiler loaded? <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_COMPILER_LOADED</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">CMAKE_C_COMPILER_LOADED</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"The C compiler ID is: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_COMPILER_ID</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"Is the C from GNU? <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_COMPILER_IS_GNUCC</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span>    <span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"The C compiler version is: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_COMPILER_VERSION</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以设置变量的东西:</p><p>set</p><p>option</p><h3 id="编译器的选定"><a href="#编译器的选定" class="headerlink" title="编译器的选定"></a>编译器的选定</h3><p>两种方式</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#第一种</span>$ cmake -D <span class="token variable">CMAKE_CXX_COMPILER</span>=clang++ ..<span class="token comment">#第二种</span>$ env CXX=clang++ cmake ..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切换构建类型"><a href="#切换构建类型" class="headerlink" title="切换构建类型"></a>切换构建类型</h2><p>cmake 通过CMAKE_BUILD_TYPE 配置构建类型</p><p>构建类型有:</p><ol><li><strong>Debug</strong>：用于在没有优化的情况下，使用带有调试符号构建库或可执行文件。</li><li><strong>Release</strong>：用于构建的优化的库或可执行文件，不包含调试符号。</li><li><strong>RelWithDebInfo</strong>：用于构建较少的优化库或可执行文件，包含调试符号。</li><li><strong>MinSizeRel</strong>：用于不增加目标代码大小的优化方式，来构建库或可执行文件。</li></ol><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment">#这是关于构建类型的</span><span class="token keyword">cmake_minimum_required</span> <span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.18</span><span class="token punctuation">)</span><span class="token keyword">project</span> <span class="token punctuation">(</span> hello <span class="token property">VERSION</span> <span class="token number">2.0.0.0</span> LANGUAGES CXX <span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">NOT</span> <span class="token variable">CMAKE_BUILD_TYPE</span><span class="token punctuation">)</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token variable">CMAKE_BUILD_TYPE</span> RELEASE <span class="token variable">CACHE</span> STRING <span class="token string">"Build type"</span> FORCE<span class="token punctuation">)</span><span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS  <span class="token string">"BUILD type:"</span> <span class="token punctuation">${</span><span class="token variable">CMAKE_BUILD_TYPE</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C flags, Debug configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_DEBUG</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C flags, Release configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_RELEASE</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C flags, Release configuration with Debug info: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_RELWITHDEBINFO</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C flags, minimal Release configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_C_FLAGS_MINSIZEREL</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C++ flags, Debug configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_DEBUG</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C++ flags, Release configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_RELEASE</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C++ flags, Release configuration with Debug info: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_RELWITHDEBINFO</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">message</span><span class="token punctuation">(</span>STATUS <span class="token string">"C++ flags, minimal Release configuration: <span class="token interpolation"><span class="token punctuation">${</span><span class="token variable">CMAKE_CXX_FLAGS_MINSIZEREL</span><span class="token punctuation">}</span></span>"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为语言指定标准"><a href="#为语言指定标准" class="headerlink" title="为语言指定标准"></a>为语言指定标准</h2><p><strong>set</strong>(CMAKE_CXX_STANDARD 17)</p><p>之前设置的<code>CMAKE_CXX_STANDARD</code>只是一个可选属性，如果编译器不支持此标准版本，则还是有可能会退化为以前的版本。如果我们想要明确表示需要某个<code>C++</code>标准，则可以通过：</p><pre class="line-numbers language-none"><code class="language-none">set(CMAKE_CXX_STANDARD_REQUIRED True)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>CXX_STANDARD</strong>会设置我们想要的标准。</p><p><strong>CXX_EXTENSIONS</strong>告诉CMake，只启用<code>ISO C++</code>标准的编译器标志，而不使用特定编译器的扩展。</p><p><strong>CXX_STANDARD_REQUIRED</strong>指定所选标准的版本。如果这个版本不可用，CMake将停止配置并出现错误。当这个属性被设置为<code>OFF</code>时，CMake将寻找下一个标准的最新版本，直到一个合适的标志。这意味着，首先查找<code>C++14</code>，然后是<code>C++11</code>，然后是<code>C++98</code>。（译者注：目前会从<code>C++20</code>或<code>C++17</code>开始查找）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vps搭建记录</title>
      <link href="2020/09/09/vps-da-jian-ji-lu/"/>
      <url>2020/09/09/vps-da-jian-ji-lu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://justhost.ru/vps_service/control/219127">justhost</a></p><p>这里我的操作系统是centos7</p><p>计划之后添加个记录</p><h2 id="选择适合自己的线路"><a href="#选择适合自己的线路" class="headerlink" title="选择适合自己的线路"></a>选择适合自己的线路</h2><p>去程查询<a href="https://tools.ipip.net/traceroute.php">ipip</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#全部整合的一个脚本</span><span class="token function">wget</span>    https://raw.githubusercontent.com/q1248/someScripts/master/install.sh<span class="token comment">#安装curl</span>yum update -y <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> <span class="token function">curl</span> -y<span class="token comment">#测试网速/硬件的脚本下载</span><span class="token function">wget</span> https://raw.githubusercontent.com/FunctionClub/ZBench/master/ZBench-CN.sh<span class="token comment">#关闭centos7的防火墙</span>systemctl stop firewalld.service <span class="token comment">#停止firewall</span>systemctl disable firewalld.service <span class="token comment">#禁止firewall开机启动</span><span class="token comment">#安装v2ray一键脚本</span><span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -s -L https://git.io/v2ray.sh<span class="token punctuation">)</span><span class="token comment">#新一键脚本</span><span class="token function">bash</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token function">curl</span> -sL https://raw.githubusercontent.com/hijkpw/scripts/master/centos_install_ss.sh<span class="token punctuation">)</span><span class="token comment">#ss脚本(可选)</span><span class="token function">wget</span> --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh<span class="token function">chmod</span> +x shadowsocks-all.sh./shadowsocks-all.sh <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">tee</span> shadowsocks-all.log<span class="token comment">#安装bbr加速脚本</span><span class="token function">wget</span> -N --no-check-certificate <span class="token string">"https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x tcp.sh <span class="token operator">&amp;&amp;</span> ./tcp.sh<span class="token comment">#kcptun脚本(可选)</span><span class="token function">wget</span> --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh<span class="token function">chmod</span> +x ./kcptun.sh./kcptun.sh<span class="token comment">#测速网</span>https://www.speedtest.net/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>使用上边的一键脚本写进docker然后写个docker的安装脚本,然后实现封装</p><p>省得在任何服务器上复制粘贴了</p><p>基本明天做个docker容器测试下就大功告成了</p><p>然后就不用担心vps这块了.我尽了我的所有能耐了,之后的就任由他发展</p><p>之后这星期必须把cmake的语法和mfc那个双缓冲搞定,不能再干其他了,太耽搁时间了</p><p><strong>已经用了脚本把上边的封装起来了,有需要,自己添加或者删除脚本内容</strong></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>关于各种vps的知识</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200913155737108.png"></p><p>关于vps暂时折腾到这里,总的来说还是俄罗斯justhost的ttk地区躲我这里来说比较稳定;aga的15块线Japan线路就能流畅观看4k,延迟也比较低</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kde解决全局代理问题</title>
      <link href="2020/08/10/kde-jie-jue-quan-ju-dai-li-wen-ti/"/>
      <url>2020/08/10/kde-jie-jue-quan-ju-dai-li-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="kde解决全局代理的问题"><a href="#kde解决全局代理的问题" class="headerlink" title="kde解决全局代理的问题"></a>kde解决全局代理的问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间换了kde,发现不能像gnome那样实现全局代理(特别是在终端里),找了解决方案,发现cgproxy比较适合我</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="下载cgproxy-并配置好配置文件"><a href="#下载cgproxy-并配置好配置文件" class="headerlink" title="下载cgproxy,并配置好配置文件"></a>下载cgproxy,并配置好配置文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S cgproxy <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他发行版参考<a href="https://github.com/springzfx/cgproxy">cgproxy官方github</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/cgproxy/config.json <span class="token comment">#打开配置文件进行配置cgproxy</span><span class="token punctuation">{</span>    <span class="token string">"port"</span><span class="token builtin class-name">:</span> <span class="token number">12345</span>,  //透明代理的端口    <span class="token string">"program_noproxy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"v2ray"</span>, <span class="token string">"qv2ray"</span><span class="token punctuation">]</span>,    <span class="token string">"program_proxy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,    <span class="token string">"cgroup_noproxy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token string">"/system.slice/v2ray.service"</span><span class="token punctuation">]</span>,    <span class="token string">"cgroup_proxy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,   //你要代理的应用,<span class="token string">"/"</span> 代表全部代理    <span class="token string">"enable_gateway"</span><span class="token builtin class-name">:</span> false,    <span class="token string">"enable_dns"</span><span class="token builtin class-name">:</span> true,    <span class="token string">"enable_udp"</span><span class="token builtin class-name">:</span> true,    <span class="token string">"enable_tcp"</span><span class="token builtin class-name">:</span> true,    <span class="token string">"enable_ipv4"</span><span class="token builtin class-name">:</span> true,    <span class="token string">"enable_ipv6"</span><span class="token builtin class-name">:</span> true,    <span class="token string">"table"</span><span class="token builtin class-name">:</span> <span class="token number">10007</span>,    <span class="token string">"fwmark"</span><span class="token builtin class-name">:</span> <span class="token number">39283</span><span class="token punctuation">}</span>systemctl <span class="token builtin class-name">enable</span> cgproxysystemctl start cgproxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="qv2ray的配置"><a href="#qv2ray的配置" class="headerlink" title="qv2ray的配置"></a>qv2ray的配置</h3><ol><li>首选项里把透明代理打开(端口就是上边配置的port</li><li>首选项–连接设置–DNS拦截打开,绕过中国大陆打开</li></ol><h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>如果遇到不能上网的情况,可能与用了docker与visual box 有关,在cgproxy的issue中也有解决方案</p><p>如果用了docker</p><p>在grub的配置文件的内核参数中添加以下内容</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">GRUB_CMDLINE_LINUX_DEFAULT</span><span class="token operator">=</span><span class="token string">" text cgroup_no_v1=net_cls,net_prio "</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可能是权限的一些问题,为了方便,我起了个别名(<br>alias ttpp=’sudo setcap “cap_net_admin,cap_net_bind_service=ep” /usr/bin/v2ray ;systemctl restart cgproxy’</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora图片上传</title>
      <link href="2020/08/06/typora-tu-pian-shang-chuan/"/>
      <url>2020/08/06/typora-tu-pian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="typora自动上传图片设置"><a href="#typora自动上传图片设置" class="headerlink" title="typora自动上传图片设置"></a>typora自动上传图片设置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有关怎么创建存储容器就不多说了,网上都有教程,主要说一下在Linux下怎么用common line 的方式配置自动上传图片</p><p>默认你已经具备以下条件</p><ol><li>找到了自己存储容器</li><li>配置好了picgo上传文件(Linux一般在用户目录的.picgo/config.json</li></ol><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先需要安装<strong>nodejs__和__npm</strong> 我的是Archlinux,其他发行版自行寻找怎么安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S nodejs <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后安装picgo  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> picgo -g<span class="token function">which</span> picgo <span class="token comment">#找到picgo的路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我这显示的是 /usr/bin/picgo</p><p>最后配置typora,在图片上传哪里添加 /usr/bin/picgo upload</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200806142428071.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本</title>
      <link href="2020/08/06/shell-jiao-ben/"/>
      <url>2020/08/06/shell-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-命令行与shell脚本编程大全"><a href="#Linux-命令行与shell脚本编程大全" class="headerlink" title="Linux 命令行与shell脚本编程大全"></a>Linux 命令行与shell脚本编程大全</h1><h2 id="基础命令参考"><a href="#基础命令参考" class="headerlink" title="基础命令参考"></a>基础命令参考</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><h4 id="内核的介绍"><a href="#内核的介绍" class="headerlink" title="内核的介绍"></a>内核的介绍</h4><p>内核主要负责以下四种功能:<br> 系统内存管理<br> 软件程序管理<br> 硬件设备管理<br> 文件系统管理</p><p>内核创建了第一个进程(称为init进程)来启动系统上所有其他进程。当内核启动时,它会<br>将init进程加载到虚拟内存中。内核在启动任何其他进程时,都会在虚拟内存中给新进程分配一<br>块专有区域来存储该进程用到的数据和代码。<br>一些Linux发行版使用一个表来管理在系统开机时要自动启动的进程。在Linux系统上,这个<br>表通常位于专门文件/etc/inittab中。</p><p>Linux 操 作 系 统 的 init 系 统 采 用 了 运 行 级 。 运 行 级 决 定 了 init 进 程 运 行 /etc/inittab 文 件 或<br>/etc/rcX.d目录中定义好的某些特定类型的进程。Linux操作系统有5个启动运行级。<br>运行级为1时,只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。<br>单用户模式通常用来在系统有问题时进行紧急的文件系统维护。显然,在这种模式下,仅有一个<br>人(通常是系统管理员)能登录到系统上操作数据。<br>标准的启动运行级是3。在这个运行级上,大多数应用软件,比如网络支持程序,都会启动。<br>另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统,允许用<br>户通过图形化桌面窗口登录系统。</p><p>在Linux内核中有两种方法用于插入设备驱动代码:<br> 编译进内核的设备驱动代码<br> 可插入内核的设备驱动模块</p><p>Linux系统将硬件设备当成特殊的文件,称为设备文件。设备文件有3种分类:<br> 字符型设备文件<br> 块设备文件<br> 网络设备文件</p><p>Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设<br>备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一<br>个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特<br>定设备。</p><p>Linux内核采用虚拟文件系统(Virtual File System,VFS)作为和每个文件系统交互的接口。<br>这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用<br>时,VFS将信息都缓存在内存中。</p><h4 id="GUN工具"><a href="#GUN工具" class="headerlink" title="GUN工具"></a>GUN工具</h4><p>GNU项目的主旨在于为Unix系统管理员设计出一套类似于Unix的环境。这个目标促使该项目<br>移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils(core<br>utilities)软件包。<br>GNU coreutils软件包由三部分构成:<br> 用以处理文件的工具<br> 用以操作文本的工具<br> 用以管理进程的工具</p><h3 id="走进shell"><a href="#走进shell" class="headerlink" title="走进shell"></a>走进shell</h3><p>tty 代表电传打字机(teletypewriter)。这是一个古老的名词,指<br>的是一台用于发送消息的机器</p><h4 id="流行的图形化终端仿真器软件包"><a href="#流行的图形化终端仿真器软件包" class="headerlink" title="流行的图形化终端仿真器软件包"></a>流行的图形化终端仿真器软件包</h4><p>Eterm <a href="http://www.eterm.org/">http://www.eterm.org</a><br>Final Term <a href="http://finalterm.org/">http://finalterm.org</a><br>GNOME Terminal <a href="https://help.gnome.org/users/gnome-terminal/stable">https://help.gnome.org/users/gnome-terminal/stable</a><br>Guake <a href="https://github.com/Guake/guake">https://github.com/Guake/guake</a><br>Konsole Terminal <a href="http://konsole.kde.org/">http://konsole.kde.org</a><br>LillyTerm <a href="http://lilyterm.luna.com.tw/index.html">http://lilyterm.luna.com.tw/index.html</a><br>LXTerminal <a href="http://wiki.lxde.org/en/LXTerminal">http://wiki.lxde.org/en/LXTerminal</a><br>mrxvt <a href="https://code.google.com/p/mrxvt">https://code.google.com/p/mrxvt</a><br>ROXTerm <a href="http://roxterm.sourceforge.net/">http://roxterm.sourceforge.net</a><br>rxvt <a href="http://sourceforge.net/projects/rxvt">http://sourceforge.net/projects/rxvt</a><br>rxvt-unicode <a href="http://software.schmorp.de/pkg/rxvt-unicode">http://software.schmorp.de/pkg/rxvt-unicode</a><br>Sakura <a href="https://launchpad.net/sakura">https://launchpad.net/sakura</a><br>st <a href="http://st.suckless.org/">http://st.suckless.org</a><br>Terminator <a href="https://launchpad.net/terminator">https://launchpad.net/terminator</a><br>Terminology <a href="http://www.enlightenment.org/p.php?p=about/terminology">http://www.enlightenment.org/p.php?p=about/terminology</a><br>tilda <a href="http://tilda.sourceforge.net/tildaabout.php">http://tilda.sourceforge.net/tildaabout.php</a><br>UXterm <a href="http://manpages.ubuntu.com/manpages/gutsy/man1/uxterm.1.html">http://manpages.ubuntu.com/manpages/gutsy/man1/uxterm.1.html</a><br>Wterm <a href="http://sourceforge.net/projects/wterm">http://sourceforge.net/projects/wterm</a></p><p>xterm <a href="http://invisible-island.net/xterm">http://invisible-island.net/xterm</a><br>Xfce4 Terminal <a href="http://docs.xfce.org/apps/terminal/start">http://docs.xfce.org/apps/terminal/start</a><br>Yakuake <a href="http://extragear.kde.org/apps/yakuake">http://extragear.kde.org/apps/yakuake</a></p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>常见fhs</p><p>/ 虚拟目录的根目录。通常不会在这里存储文件<br>/bin 二进制目录,存放许多用户级的GNU工具<br>/boot 启动目录,存放启动文件<br>/dev 设备目录,Linux在这里创建设备节点<br>/etc 系统配置文件目录<br>/home 主目录,Linux在这里创建用户目录<br>/lib 库目录,存放系统和应用程序的库文件<br>/media 媒体目录,可移动媒体设备的常用挂载点<br>/mnt 挂载目录,另一个可移动媒体设备的常用挂载点<br>/opt 可选目录,常用于存放第三方软件包和数据文件<br>/proc 进程目录,存放现有硬件及当前进程的相关信息<br>/root root用户的主目录<br>/sbin 系统二进制目录,存放许多GNU管理员级工具<br>/run 运行目录,存放系统运作时的运行时数据<br>/srv 服务目录,存放本地服务的相关文件<br>/sys 系统目录,存放系统硬件信息的相关文件<br>/tmp 临时目录,可以在该目录中创建和删除临时工作文件<br>/usr 用户二进制目录,大量用户级的GNU工具和数据文件都存储在这里<br>/var 可变目录,用以存放经常变化的文件,比如日志文件</p><p>ls常见指令</p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-F 在显示的目录后边添加正斜线表示这是一个目录-R 列出当前文件子目录中的文件-a-R<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>cp 常见</p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-R 递归复制文件夹里的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ln</p><p>zsh</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">-s 创建软链接不加任何参数 创建硬链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>tar</p><table><thead><tr><th align="left">参数</th><th align="left">参数描述</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">创建新的档案文件</td></tr><tr><td align="left">-C</td><td align="left">指定到要解压到的目录。注意：该目录必须存在</td></tr><tr><td align="left">-f</td><td align="left">指定打包的文件名。在f之后要立即接打包文件名！不要再加参数！</td></tr><tr><td align="left">-x</td><td align="left">解压</td></tr><tr><td align="left">-O</td><td align="left">将文件解压到标准输出</td></tr><tr><td align="left">-p</td><td align="left">使用原文件的原来属性</td></tr><tr><td align="left">-P</td><td align="left">创建归档文件，使用绝对路径</td></tr><tr><td align="left">-t</td><td align="left">列出档案文件中的内容</td></tr><tr><td align="left">-r</td><td align="left">向压缩归档文件末尾追加文件</td></tr><tr><td align="left">-u</td><td align="left">更新原压缩包中的文件</td></tr><tr><td align="left">-v</td><td align="left">显示详细过程</td></tr><tr><td align="left">-z</td><td align="left">使用gzip压缩，一般格式为xx.tar.gz或xx. tgz</td></tr><tr><td align="left">-Z</td><td align="left">有compress</td></tr><tr><td align="left">-j</td><td align="left">使用bzip2压缩，一般格式为xxx.tar.bz2</td></tr><tr><td align="left">–exclude</td><td align="left">在压缩过程中，排除某个文件（exclude在排除时，需要先写出）</td></tr><tr><td align="left">–remove-files</td><td align="left">在完成打包后，删除原文件夹</td></tr></tbody></table><h3 id="检测程序"><a href="#检测程序" class="headerlink" title="检测程序"></a>检测程序</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>ps 有好几种风格，我选择Unix风格的</p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 常见的</span><span class="token function">ps</span>  查看当前bash的进程<span class="token function">ps</span> -ef 列出全部的<span class="token function">ps</span> -el列出更为详细的进程信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 参考</span>-A 显示所有进程-N 显示与指定参数不符的所有进程-a 显示除控制进程<span class="token punctuation">(</span>session leader <span class="token punctuation">)</span>和无终端进程外的所有进程-d 显示除控制进程外的所有进程-e 显示所有进程-C cmdlist 显示包含在 cmdlist 列表中的进程-G grplist 显示组ID在 grplist 列表中的进程-U userlist 显示属主的用户ID在 userlist 列表中的进程-g grplist 显示会话或组ID在 grplist 列表中的进程-p pidlist 显示PID在 pidlist 列表中的进程-s sesslist-t ttylist 显示终端ID在 ttylist 列表中的进程-u userlist 显示有效用户ID在 userlist 列表中的进程-F 显示更多额外输出<span class="token punctuation">(</span>相对 -f 参数而言<span class="token punctuation">)</span>-O <span class="token function">format</span> 显示默认的输出列以及 <span class="token function">format</span> 列表指定的特定列-M 显示进程的安全信息-c 显示进程的额外调度器信息-f 显示完整格式的输出-j 显示任务信息-l 显示长列表-o <span class="token function">format</span> 仅显示由 <span class="token function">format</span> 指定的列-y 不要显示进程标记<span class="token punctuation">(</span>process flag,表明进程状态的标记<span class="token punctuation">)</span>-Z 显示安全标签<span class="token punctuation">(</span>security context<span class="token punctuation">)</span> <span class="token number">1</span> 信息-H 用层级格式来显示进程<span class="token punctuation">(</span>树状,用来显示父进程<span class="token punctuation">)</span>-n namelist 定义了 WCHAN 列显示的值-w 采用宽输出模式,不限宽度显示-L 显示进程中的线程-V 显示 <span class="token function">ps</span> 命令的版本号但是仍然还有很多没有列出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关输出的含义：</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718141755982.png" alt="image-20200718141755982"></p><p><strong>image-20200718141755982</strong></p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> F :内核分配给进程的系统标记。 S :进程的状态<span class="token punctuation">(</span>O代表正在运行<span class="token punctuation">;</span>S代表在休眠<span class="token punctuation">;</span>R代表可运行,正等待运行<span class="token punctuation">;</span>Z代表僵化,进程已结但父进程已不存在<span class="token punctuation">;</span>T代表停止<span class="token punctuation">)</span>。 PRI :进程的优先级<span class="token punctuation">(</span>越大的数字代表越低的优先级<span class="token punctuation">)</span> NI :谦让度值用来参与决定优先级。 ADDR :进程的内存地址。 SZ :假如进程被换出,所需交换空间的大致大小。 WCHAN :进程休眠的内核函数的地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718141931437.png" alt="image-20200718141931437"></p><p><strong>image-20200718141931437</strong></p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C: 进程生命周期中的CPU利用率TIME：进程需要的累计CPU时间CMD：启动的程序的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>动态监测进程的一个命令</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718143035046.png" alt="image-20200718143035046"></p><p><strong>image-20200718143035046</strong></p><p> VIRT:进程占用的虚拟内存总量。<br> RES:进程占用的物理内存总量。<br> SHR:进程和其他进程共享的内存总量。<br> S:进程的状态(D代表可中断的休眠状态,R代表在运行状态,S代表休眠状态,T代表<br>跟踪状态或停止状态,Z代表僵化状态)</p><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>查看某个设备还有多少空间</p><p>配合lsblk可以更全面了解设备空间占用的情况</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>查看某个文件（夹）的大小</p><p>-c 显示总大小</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>排序</p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-b --ignore-leading-blanks 排序时忽略起始的空白-C --check<span class="token operator">=</span>quiet 不排序,如果数据无序也不要报告-c --check 不排序,但检查输入数据是不是已排序<span class="token punctuation">;</span>未排序的话,报告-d --dictionary-order 仅考虑空白和字母,不考虑特殊字符-f --ignore-case 默认情况下,会将大写字母排在前面<span class="token punctuation">;</span>这个参数会忽略大小写-g --general-number-sort 按通用数值来排序<span class="token punctuation">(</span>跟 -n 不同,把值当浮点数来排序,支持科学计数法表示的值<span class="token punctuation">)</span>-i --ignore-nonprinting 在排序时忽略不可打印字符-k --key<span class="token operator">=</span>POS1<span class="token punctuation">[</span>,POS2<span class="token punctuation">]</span> 排序从POS1位置开始<span class="token punctuation">;</span>如果指定了POS2的话,到POS2位置结束-M --month-sort 用三字符月份名按月份排序-m --merge 将两个已排序数据文件合并-n --numeric-sort 按字符串数值来排序<span class="token punctuation">(</span>并不转换为浮点数<span class="token punctuation">)</span>-o --output<span class="token operator">=</span>file 将排序结果写出到指定的文件中-R --random-sort 按随机生成的散列表的键值排序--random-source<span class="token operator">=</span>FILE 指定 -R 参数用到的随机字节的源文件-r --reverse 反序排序<span class="token punctuation">(</span>升序变成降序<span class="token punctuation">)</span>-S --buffer-size<span class="token operator">=</span>SIZE 指定使用的内存大小-s --stable 禁用最后重排序比较-T --temporary-directory<span class="token operator">=</span>DIR 指定一个位置来存储临时工作文件-t --field-separator<span class="token operator">=</span>SEP 指定一个用来区分键位置的字符-u --unique 和 -c 参数一起使用时,检查严格排序<span class="token punctuation">;</span>不和 -c 参数一起用时,仅输出第一例相似的两行-z --zero-terminated 用NULL字符作为行尾,而不是用换行符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="压缩与解压"><a href="#压缩与解压" class="headerlink" title="压缩与解压"></a>压缩与解压</h4><p>解压工具</p><table><thead><tr><th align="left">工具</th><th align="left">扩展名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bzip2</td><td align="left">.bz2</td><td align="left">采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码</td></tr><tr><td align="left">compress</td><td align="left">.Z</td><td align="left">最初的Unix文件压缩工具,已经快没人用了</td></tr><tr><td align="left">gzip .gz</td><td align="left">.gz</td><td align="left">GNU压缩工具,用Lempel-Ziv编码</td></tr></tbody></table><p>gzip xx 直接就能解压.gz文件</p><p>tar</p><p>-A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件<br>-c –create 创建一个新的tar归档文件<br>-d –diff 检查归档文件和文件系统的不同之处<br>–delete 从已有tar归档文件中删除<br>-r –append 追加文件到已有tar归档文件末尾<br>-t –list 列出已有tar归档文件的内容<br>-u –update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中<br>-x –extract 从已有tar归档文件中提取文</p><p>命令选项</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-C dir</td><td align="left">切换到指定目录</td></tr><tr><td align="left">-f file</td><td align="left">输出结果到file</td></tr><tr><td align="left">-j</td><td align="left">讲输出重定向给bzip2命令来压缩</td></tr><tr><td align="left">-p</td><td align="left">保留所有文件权限</td></tr><tr><td align="left">-v</td><td align="left">在处理文件时显示详细过程</td></tr><tr><td align="left">-z</td><td align="left">将输出重定向给gzip软件压缩</td></tr></tbody></table><p>常用组合：</p><p>tar -zcf xx.tar.gz file1，file2,file3….</p><p>tar -xf xx.tar.gz 解压打包过的并且压缩过的文件</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>/etc/passwd中文件含义</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718145559428.png" alt="image-20200718145559428"></p><p><strong>image-20200718145559428</strong></p><p> 登录用户名<br> 用户密码<br> 用户账户的UID(数字形式)<br> 用户账户的组ID(GID)<br> 用户账户的文本描述(称为备注字段)<br> 用户HOME目录的位置<br> 用户的默认shell</p><p>修改这个文件当中的内容十分危险,使用权限管理工具可以安全更改</p><p>密码x因为加密了</p><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-c comment 给新用户添加备注-d home_dir 为主目录指定一个名字<span class="token punctuation">(</span>如果不想用登录名作为主目录名的话<span class="token punctuation">)</span>-e expire_date 用YYYY-MM-DD格式指定一个账户过期的日期-f inactive_days 指定这个账户密码过期后多少天这个账户被禁用<span class="token punctuation">;</span> <span class="token number">0</span> 表示密码一过期就立即禁用, <span class="token number">1</span> 表示禁用这个功能-g initial_group 指定用户登录组的GID或组名-G group <span class="token punctuation">..</span>. 指定用户除登录组之外所属的一个或多个附加组-k 必须和 -m 一起使用,将/etc/skel目录的内容复制到用户的<span class="token environment constant">HOME</span>目录-m 创建用户的<span class="token environment constant">HOME</span>目录-M 不创建用户的<span class="token environment constant">HOME</span>目录<span class="token punctuation">(</span>当默认设置里要求创建时才使用这个选项<span class="token punctuation">)</span>-n 创建一个与用户登录名同名的新组-r 创建系统账户-p <span class="token function">passwd</span> 为用户账户指定默认密码-s shell 指定默认的登录shell-u uid 为账户指定唯一的<span class="token environment constant">UID</span>修改默认值的参数-b default_home 更改默认的创建用户<span class="token environment constant">HOME</span>目录的位置-e expiration_date 更改默认的新账户的过期日期-f inactive 更改默认的新用户从密码过期到账户被禁用的天数-g group 更改默认的组名称或GID-s shell 更改默认的登录shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般就是 useradd -m -G wheel horo</p><p>wheel代表在sudo那个文件里取消注释的那个组(加入这个组可以取得root的一些权限) horo就是创建的用户名</p><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>userdel -r name 删除账户(但是不会删除太干净)</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>-l 修改用户账户的登录名。<br>-L 锁定账户,使用户无法登录。<br>-p 修改账户的密码。<br>-U 解除锁定,使用户能够登录。</p><h4 id="修改用户的工具"><a href="#修改用户的工具" class="headerlink" title="修改用户的工具"></a>修改用户的工具</h4><p>usermod 修改用户账户的字段,还可以指定主要组以及附加组的所属关系<br>passwd 修改已有用户的密码<br>chpasswd 从文件中读取登录名密码对,并更新密码<br>chage 修改密码的过期日期<br>chfn 修改用户账户的备注信息<br><strong>chsh</strong> 修改用户账户的默认登录shell</p><h4 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h4><p>groupadd 命令可在系统上创建新组</p><p><strong>usermod -G shared rich</strong> 讲rich加入到share组中</p><p>group代表修改组</p><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>chmod　改变文件的权限</p><p>chown 改变文件的所有者 -Ｒ　递归修改</p><p>chgrp　改变文件的组</p><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>主要就是知道ext系列是经典linux文件系统,新的比较好的有xfs 具体介绍还是去看鸟哥的</p><p>cfdisk 进行分区啥的</p><p>lsblk 列出当前的文件系统</p><p>理解LVM这个概念,简单来说就是linux支持将许多不同的物理磁盘合并为一个分区,这对于扩容来说,就省得备份了.或者是将一个磁盘分割成为许多不同的分区,极大方便了linux文件的管理</p><h2 id="理解shell"><a href="#理解shell" class="headerlink" title="理解shell"></a>理解shell</h2><p>当你登录Linux系统时,bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里<br>读取命令:<br>/etc/profile</p><p>HOME/.bashrc<br>​HOME/.bash_login<br>HOME/.profile<br>/etc/profile文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行<br>这个启动文件。</p><hr><p>command1 &amp; 讲命令放到后台执行,但是标准输出仍然会输出到屏幕上</p><p>jobs 列出后台执行的命令</p><p>Ctrl+Z 将一个正在执行的任务放到后台,并休眠</p><p>fg %num 将任务放到前台执行,并唤醒</p><hr><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>$env 显示变量当中的内容</p><p>export env=xxx 声明这个是全局环境变量,子shell可以使用这个变量,但关机后就会失效</p><p>可以在.zhsrv(shell的配置文件)中声明,来获得持久化的使用 因为每启动一次shell都会source下.zshrc 中的内容</p><h2 id="shell基础语法"><a href="#shell基础语法" class="headerlink" title="shell基础语法"></a>shell基础语法</h2><h3 id="流程控制的语法"><a href="#流程控制的语法" class="headerlink" title="流程控制的语法"></a>流程控制的语法</h3><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> condition    <span class="token keyword">then</span>         <span class="token builtin class-name">command</span>    <span class="token keyword">else</span>        <span class="token builtin class-name">command</span> <span class="token keyword">fi</span><span class="token keyword">case</span> var <span class="token keyword">in</span> xxx    part1<span class="token punctuation">)</span>        <span class="token builtin class-name">command</span>    part2<span class="token punctuation">)</span>        <span class="token builtin class-name">command</span>    *<span class="token punctuation">)</span>        <span class="token builtin class-name">command</span><span class="token keyword">esac</span><span class="token keyword">while</span> var  <span class="token keyword">in</span> xx,xx,xx,xx,xx<span class="token punctuation">(</span>以字段分割符分割的列表<span class="token punctuation">)</span><span class="token keyword">do</span>    <span class="token builtin class-name">command</span><span class="token keyword">done</span><span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token keyword">do</span>    <span class="token builtin class-name">command</span><span class="token keyword">done</span><span class="token keyword">while</span> condition<span class="token keyword">do</span>        <span class="token builtin class-name">command</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718153735701.png" alt="image-20200718153735701"></p><p><strong>image-20200718153735701</strong></p><p>exit 0</p><p>用$? 可以看出上一条命令的退出码</p><h4 id="条件的设定"><a href="#条件的设定" class="headerlink" title="条件的设定"></a>条件的设定</h4><p>数字 字符串 文件</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718154023094.png" alt="image-20200718154023094"></p><p><strong>image-20200718154023094</strong></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718154046354.png" alt="image-20200718154046354"></p><p><strong>image-20200718154046354</strong></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718154119647.png" alt="image-20200718154119647"></p><p><strong>image-20200718154119647</strong></p><p>以上三中比较都可以用[ ]符号将上述比较方法放在condition中</p><p>(()) 里面的条件可以用高级语言中的比较运算符直接进行比较,对于数字来说</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200718154330670.png" alt="image-20200718154330670"></p><p><strong>image-20200718154330670</strong></p><p>字符串使用[[]]即可</p><h3 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h3><p>getopts 命令能够和已有的shell参数变量配合默契。每次调用它时,它一次只处理命令行上检测到的一个参数。处理完所有的参数后,它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。<br>getopts 命令的格式如下:<br>getopts optstring variable<br>optstring 值类似于 getopt 命令中的那个。有效的选项字母都会列在 optstring 中,如果<br>选项字母要求有个参数值,就加一个冒号。要去掉错误消息的话,可以在 optstring 之前加一个<br>冒号。 getopts 命令将当前参数保存在命令行中定义的 variable 中。<br>getopts 命令会用到两个环境变量。如果选项需要跟一个参数值, OPTARG 环境变量就会保<br>存这个值。 OPTIND 环境变量保存了参数列表中 getopts 正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了。</p><p>variable 代表正在处理的参数</p><p>OPTARG 参数值</p><p>OPTND 正在处理的位置</p><p>示例:</p><p>shell</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> :abc:  opt<span class="token keyword">do</span>    <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$opt</span>"</span> <span class="token keyword">in</span>    a<span class="token punctuation">)</span>echo this is -a      <span class="token builtin class-name">echo</span> the postion is <span class="token environment constant">$OPTIND</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    b<span class="token punctuation">)</span>echo this is -b      <span class="token builtin class-name">echo</span> the postion is <span class="token environment constant">$OPTIND</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    c<span class="token punctuation">)</span>echo this is -c with part <span class="token variable">$OPTARG</span>       <span class="token builtin class-name">echo</span> the postion is <span class="token environment constant">$OPTIND</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>echo unknown part      <span class="token builtin class-name">echo</span> the postion is <span class="token environment constant">$OPTIND</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用read即可</p><p>read var1</p><p>-s 输入用密码方式</p><p>-t 超时设置</p><p>-n2 输入两个字母时就会停止读取输入</p><p>$0 代表文件名</p><p>$@ 代表所有参数列表(但是会以空格分隔符分割)</p><p>$#命令行参数的个数</p><p>$* 代表所有参数列表,但是是整个字符串的</p><h3 id="展示输出"><a href="#展示输出" class="headerlink" title="展示输出"></a>展示输出</h3><p>文件描述符:</p><p>0 1 2 3–9</p><p>临时重定向</p><blockquote><p>2&gt; file 将stderror 输入到文件中</p><p>&gt;&amp;2 代表这一条语句向这标准错误输出写入内容</p></blockquote><p>永久重定向</p><blockquote><p>exec 1&gt; file 永久将std 输入到file中</p><p>exec 3&gt;&amp;1 将文件描述符3标记的输出到stdout</p><p>&amp;&gt; file 标准输出和错误输出同时重定向到一个file</p><p>echo xxxx &gt;&amp;3 将xxx输入到文件描述符三定位的地方</p></blockquote><p>一般使用3-6文件描述符的时候都是让他记住一个位置,之后再使用这个位置</p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">3</span>&lt;</span><span class="token file-descriptor important">&amp;0</span><span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>test.log<span class="token builtin class-name">read</span> var1   这就是直接从teet.log 读取数据了<span class="token builtin class-name">exec</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span><span class="token file-descriptor important">&amp;3</span>   标准输入恢复从键盘输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实都可以理解为: 数据来源&gt;数据写入到哪里</p><p>mkemp.xxxxx 生成随机名称的文件</p><p>注意:当程序在后台进行的时候,stdout和stderror仍然会出现在屏幕上</p><h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>crontab 的基本格式是：</p><pre class="line-numbers language-none"><code class="language-none">&lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt; &lt;命令&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>分钟</em> 值从 0 到 59.</li><li><em>小时</em> 值从 0 到 23.</li><li><em>日</em> 值从 1 到 31.</li><li><em>月</em> 值从 1 到 12.</li><li><em>星期</em> 值从 0 到 6, 0 代表星期日.</li></ul><p>空格用来分开字段，可以用下面特殊字符设定范围:</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*****</td><td align="left">通配符，表示所有支持的时间值</td></tr><tr><td align="left"><strong>,</strong></td><td align="left">用逗号分隔多个时间</td></tr><tr><td align="left"><strong>-</strong></td><td align="left">连接两个数值，给出一个范围</td></tr><tr><td align="left"><strong>/</strong></td><td align="left">指定一个周期或频率</td></tr></tbody></table><h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><pre class="line-numbers language-none"><code class="language-none">name() {return num(可选的语句,原理等同于 状态退出码)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>$1 2 3 4 … 表示的是传给他的参数</p><p>name par1 par2 ….</p><p>使用写好的函数库,先提前source下库,然后再调用库里的函数</p><p>接受函数的输出:</p><p> 使用命令转置 var=<code>name</code></p><h2 id="sed和gawk基础"><a href="#sed和gawk基础" class="headerlink" title="sed和gawk基础"></a>sed和gawk基础</h2><p>这都是对流使用的编辑器,经常用于格式化文本或者批量处理某些文本,深入进去又是一门很大的学问,现在暂时用不到,先看看基础</p><p>基本格式：<br>sed ‘数字|/文本/commond/ 其他参数’<br>sed ‘范围 {<br>command1<br>commond2<br>…<br>}</p><p>替换</p><p>sed ‘1,3s/old/new/flag’</p><p>flag:<br>w xx.text<br>g gloable<br>p 原先行的内容要打印出来<br>3 新文本替换第3处的内容</p><p>删除</p><p>sed ‘1,3d’<br>sed ‘1,3/word/d’ 删除有个这个单词的行</p><p>插入</p><p>打印</p><p>p 打印这一行的所有文本<br>‘=’ 打印行号</p><p>从文件读取</p><p>‘r filename’</p><p>向文件写入<br>‘w filename’<br>…….之后的以后有时间用到再更新吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker简单指令</title>
      <link href="2020/08/06/docker-jian-dan-zhi-ling/"/>
      <url>2020/08/06/docker-jian-dan-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-简明命令"><a href="#docker-简明命令" class="headerlink" title="docker 简明命令"></a>docker 简明命令</h1><h2 id="镜像有关的"><a href="#镜像有关的" class="headerlink" title="镜像有关的"></a>镜像有关的</h2><p>shell</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker images 查看镜像列表docker run -it 以交互式的方式进入容器Ctrl+P+Q 在容器内将容器后台执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="容器有关的"><a href="#容器有关的" class="headerlink" title="容器有关的"></a>容器有关的</h2><p>shell</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker start xxx 启动一个创建过的容器docker stop xxx  停止正在运行的容器docker <span class="token function">ps</span>        列出之前存在过的所有容器docker <span class="token function">kill</span> xx   杀死某个容器docker <span class="token function">rm</span>  容器名字  删除某些容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><p>shell</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker <span class="token function">cp</span> xx xx 将容器上的文件和主机上的文件互相拷贝docker <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>联合文件系统</p><p>就是分层的概念，底层是boot 上边是内核，需要什么加什么，可以逐级叠加</p><p>各个层之间也可以复用</p><p>docker镜像相当于内核</p><p>容器相当于库和软件的集合，每个容器之间是相互隔离的，相当于一个个小的虚拟机</p><h1 id="镜像的提交"><a href="#镜像的提交" class="headerlink" title="镜像的提交"></a>镜像的提交</h1><p>docker commit -m=”” -a=”” id name:tag</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>docker run -it -v 主机目录容器目录 -p 主机端口:容器端口</p><p>两者的目录里内容是相同的</p><pre class="line-numbers language-none"><code class="language-none">docker run -it --name=“sqlservice” -e MYSQL_ROOT_PASSWORD=123 -p 8080:8080 -v /本地目录:容器内目录:ro<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ro代表这个文件夹是只读的，容器内不不能改变他的内容</p><h4 id="用dockerfile挂载文件"><a href="#用dockerfile挂载文件" class="headerlink" title="用dockerfile挂载文件"></a>用dockerfile挂载文件</h4><p>REOM centos</p><p>VOLUME [“volume1”,”volume2] //这种方法是生成的匿名目录需要 docker inspect id 看到他挂载在哪里</p><p>CMD echo ——end——-</p><p>CMD /bin/bash</p><h4 id="容器之间共享数据"><a href="#容器之间共享数据" class="headerlink" title="容器之间共享数据"></a>容器之间共享数据</h4><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200716214150932.png" alt="image-20200716214150932"></p><p><strong>image-20200716214150932</strong></p><p>这样共享的机制，相当于共享的文件除非所有容器都被删除了，否则共享的数据永远存在共享文件之间的容器之间</p><p>docker run -it –volumes-from 6d0b8 d7a</p><h2 id="docker-file-语法"><a href="#docker-file-语法" class="headerlink" title="docker file 语法"></a>docker file 语法</h2><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200716222340941.png" alt="image-20200716222340333"></p><p><strong>image-20200716222340333</strong></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200716222514613.png" alt="image-20200716222514613"></p><p><strong>image-20200716222514613</strong></p><p>docker</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker"><span class="token keyword">FROM</span> centos<span class="token punctuation">:</span>7<span class="token keyword">MAINTAINER</span> wwtg99 &lt;email<span class="token punctuation">&gt;</span><span class="token keyword">RUN</span> yum install <span class="token punctuation">-</span>y     libtool \    wget \    make \    cmake126<span class="token keyword">VOLUME</span> <span class="token punctuation">[</span><span class="token string">"/data/www"</span><span class="token punctuation">,</span> <span class="token string">"/data/conf/nginx"</span><span class="token punctuation">,</span> <span class="token string">"/data/conf/supervisord"</span><span class="token punctuation">,</span> <span class="token string">"/data/log"</span><span class="token punctuation">,</span> <span class="token string">"/data/script"</span><span class="token punctuation">]</span><span class="token keyword">EXPOSE</span> 80 443<span class="token keyword">ENV</span> mydir=/home<span class="token keyword">WORKDIR</span> $ENV<span class="token keyword">CMD</span> echo hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker build -t wwtg99/docker-nginx-php7:0.1 --rm <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200717162218990.png" alt="image-20200717162218990"></p><p><strong>image-20200717162218990</strong></p><p>用的是veth-pair这种技术</p><p>容器之间互相能网络连通</p><p>docker –net bridge images</p><p>–net 后边是自己设置的网络名称</p><p>docker network creaat 就是创建网络</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200717163604389.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式笔记</title>
      <link href="2020/08/06/zheng-ze-biao-da-shi-bi-ji/"/>
      <url>2020/08/06/zheng-ze-biao-da-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>练习网站:<a href="https://regexr-cn.com/">https://regexr-cn.com/</a></p><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">元字符    <span class="token punctuation">[</span> <span class="token punctuation">]</span> 里边放的是选项，包含里边的一个字符    <span class="token builtin class-name">.</span>   表示一个字符    <span class="token punctuation">[</span> ^<span class="token punctuation">]</span> 表示除了什么    * 相当于 <span class="token punctuation">{</span><span class="token number">0</span>，$<span class="token punctuation">}</span>     + 相当于 <span class="token punctuation">{</span><span class="token number">1</span>，$<span class="token punctuation">}</span>    <span class="token punctuation">(</span>  <span class="token punctuation">)</span>     <span class="token operator">|</span>     <span class="token punctuation">\</span>    ^ 从开始行开始匹配    $ 从末端开始匹配u快捷表示简写    描述<span class="token builtin class-name">.</span>    除换行符外的所有字符<span class="token punctuation">\</span>w    匹配所有字母数字，等同于 <span class="token punctuation">[</span>a-zA-Z0-9_<span class="token punctuation">]</span><span class="token punctuation">\</span>W    匹配所有非字母数字，即符号，等同于： <span class="token punctuation">[</span>^<span class="token punctuation">\</span>w<span class="token punctuation">]</span><span class="token punctuation">\</span>d    匹配数字： <span class="token punctuation">[</span><span class="token number">0</span>-9<span class="token punctuation">]</span><span class="token punctuation">\</span>D    匹配非数字： <span class="token punctuation">[</span>^<span class="token punctuation">\</span>d<span class="token punctuation">]</span><span class="token punctuation">\</span>s    匹配所有空格字符，等同于： <span class="token punctuation">[</span><span class="token punctuation">\</span>t<span class="token punctuation">\</span>n<span class="token punctuation">\</span>f<span class="token punctuation">\</span>r<span class="token punctuation">\</span>p<span class="token punctuation">{</span>Z<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">\</span>S    匹配所有非空格字符： <span class="token punctuation">[</span>^<span class="token punctuation">\</span>s<span class="token punctuation">]</span><span class="token punctuation">\</span>f    匹配一个换页符<span class="token punctuation">\</span>n    匹配一个换行符<span class="token punctuation">\</span>r    匹配一个回车符<span class="token punctuation">\</span>t    匹配一个制表符<span class="token punctuation">\</span>v    匹配一个垂直制表符<span class="token punctuation">\</span>p    匹配 CR/LF（等同于 <span class="token punctuation">\</span>r<span class="token punctuation">\</span>n），用来匹配 DOS 行终止符各种断言?<span class="token operator">=</span>    正先行断言-存在?<span class="token operator">!</span>    负先行断言-排除?<span class="token operator">&lt;</span><span class="token operator">=</span>    正后发断言-存在?<span class="token operator">&lt;</span><span class="token operator">!</span>    负后发断言-排除标志标志    描述i    忽略大小写。g    全局搜索。m    多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。各种断言?<span class="token operator">=</span>    正先行断言-存在?<span class="token operator">!</span>    负先行断言-排除?<span class="token operator">&lt;</span><span class="token operator">=</span>    正后发断言-存在?<span class="token operator">&lt;</span><span class="token operator">!</span>    负后发断言-排除标志标志    描述i    忽略大小写。g    全局搜索。m    多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux安装</title>
      <link href="2020/08/06/archlinux-an-zhuang/"/>
      <url>2020/08/06/archlinux-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Arch-Linux-安装"><a href="#Arch-Linux-安装" class="headerlink" title="Arch  Linux 安装"></a>Arch  Linux 安装</h1><p>重装好几次了,这次总结一点经验<br>注意:这篇文章具有时效性,具体请参考<a href="https://wiki.archlinux.org/index.php/installation_guide">arch wiki</a></p><h2 id="安装桌面环境前的准备"><a href="#安装桌面环境前的准备" class="headerlink" title="安装桌面环境前的准备"></a>安装桌面环境前的准备</h2><ul><li><p>进入bios，选择U盘启动</p></li><li><p>连接网络</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> dhcpcdsystemctl restart dhcpcd<span class="token function">ping</span> www.baidu.com<span class="token comment">#确认是否连接网络成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>同步时间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">timedatectl set-ntp <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改软件源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/pacman.d/mirrorlist Server <span class="token operator">=</span> https://mirrors.huaweicloud.com/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span> Server <span class="token operator">=</span> http://mirrors.aliyun.com/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果需要archlinuxcn源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Server <span class="token operator">=</span> https://mirrors.huaweicloud.com/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span>Server <span class="token operator">=</span> http://mirrors.aliyun.com/archlinux/<span class="token variable">$repo</span>/os/<span class="token variable">$arch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>分区</p><p>我给linux准备了80G空间（因为我电脑只有一块240G的固态），分了8G的交换空间，剩下的是一个72G的区，使用cfdisk分区</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cfdisk</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>格式化</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkfs.ext4 /dev/sda2mkfs.vfat /dev/sda3<span class="token function">mkswap</span> /dev/sda4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>挂载</p><p>/dev/sda2 是EFI分区</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> /dev/sda2 /mnt<span class="token function">mkdir</span> /mnt/boot<span class="token function">mount</span> /dev/sda3 /mnt/boot <span class="token function">swapon</span> /dev/sda4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>安装系统和基本的软件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacstrap /mnt base linux linux-firmware base-devel <span class="token function">vim</span> e2fsprogs iw wpa_supplicant dhcpcd  ntfs-3g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>s2fsprogs: 文件系统工具</p></li><li><p>进入chroot环境</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">genftab   -U /mnt <span class="token operator">&gt;&gt;</span> /mnt/etc/fsaknightive <span class="token comment">#生成磁盘挂载表</span>arch-chroot /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设置时区</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc --utc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改locale.gen文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/locale.gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 en_US.UTF-8 UTF-8   取消注释</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">locale-gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建locale.conf，设置自己的locale</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>en_US.UTF-8 <span class="token operator">&gt;</span> /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置主机名字</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> arch-linux <span class="token operator">&gt;</span> /etc/hostname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置root密码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装grub</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S efibootmgr dosfstools grub os-prober<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>efibootmgr：修改UEFI固件中的信息</p></li><li><p>os-prober：脚本为内核和其它分区里的操作系统创建菜单项，我是双系统，所以安装了这个，如果只有一个系统，可以不用安装</p></li><li><p>dosftools：操作FAT/FAT32文件系统的用户控件工具</p></li><li><p>将grub安装到硬盘</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grub-install --target<span class="token operator">=</span>x86_64-efi --efi-directory<span class="token operator">=</span>/boot --bootloader-id<span class="token operator">=</span>grub --recheck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>生成配置文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置sudo</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">visudo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 %wheel ALL=(ALL) ALL前的注释去掉</p></li></ul></li></ul><h2 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h2><p>我选择的是kde，一开始有考虑xfce, 但是后来觉得我的电脑应该没问题吧，所以就试了试kde</p><ul><li><p>安装桌面环境需要的基础包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S xorg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接默认回车就行了</p></li><li><p>安装中文字体</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S ttf-dejavu wqy-microhei<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>新建一个用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> -m -G wheel aknightive<span class="token function">passwd</span> aknightive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>下载kde</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S plasma kde-applicantionspacman -S sddm sddm-kcm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sddm: 显示管理器</p></li><li><p>激活sddm</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> sddm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>下载NetworkManager并激活</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S networkmanager net-toolssystemctl <span class="token builtin class-name">enable</span> NetworkManager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>注意大小写</p></blockquote></li><li><p>下载音频驱动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S alsa-utils pulseaudio pulseaudio-alsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>本地化</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/locgle.gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉zh_CN.UTF-8 Utf-8 的注释</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">locale-gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改locale.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">用 <span class="token function">su</span> 切换到刚建立的用户，然后编辑 ~/.config/locale.conf 修改自己的 Locale <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>zh_CN.UTF-8<span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span>zh_CN.UTF-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>安装中文输入法</p><p> 我已经换成了fcitx5),安装教程参考<a href="https://wiki.archlinux.org/index.php/Fcitx5">fcitx5的Arch wiki</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/aknightive/.xprofile<span class="token comment">#其中输入下面内容</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span>zh_CN.UTF-8  //前两个是把自己的桌面环境设置为中文,当然,不想要中文也可以不设置<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">LC_ALL</span></span><span class="token operator">=</span>zh_CN.UTF-8<span class="token builtin class-name">export</span> <span class="token assign-left variable">GTK_IM_MODULE</span><span class="token operator">=</span>fcitx<span class="token builtin class-name">export</span> <span class="token assign-left variable">QT_IM_MODULE</span><span class="token operator">=</span>fcitx<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">XMODIFIERS</span></span><span class="token operator">=</span><span class="token string">"@im=fcitxw"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>离开chroot环境</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>卸载挂载的分区</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">umount</span> -R /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="进行桌面的美化"><a href="#进行桌面的美化" class="headerlink" title="进行桌面的美化"></a>进行桌面的美化</h2><p>这里我用的是mac风格的主题,如果有其他需求,可以忽略这一部分</p><p>先展示下我的桌面</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200805213555777.png"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200805213643120.png"></p><h3 id="下载全局主题"><a href="#下载全局主题" class="headerlink" title="下载全局主题"></a>下载全局主题</h3><p>由于kde自带的主题商店和龟速一般,由于自己用的是Archlinux,因此有些主题被打包发到了Aur上面,我们可以直接通过yay安装</p><p>我的主题:Layan </p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200805233206232.png"></p><p>选择自己想要的进行安装即可</p><p>之后下载图标主题,我用的是<strong>McMojave-circle-blue</strong> ,用同样的方法进行安装</p><ul><li>在设置–全局主题 选择刚才下载的<strong>Layan</strong> 主题 同时勾上<strong>使用来自主题的布局</strong>  最后应用</li><li>设置–图标 选择一个你喜欢的图标  然后应用即可</li><li>打开终端 下载<strong>latte-dock</strong> 即可拥有dock栏</li></ul><p>基本上我的就是这些</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><blockquote><p>谷歌浏览器插件 <a href="https://myonedex.oss-cn-beijing.aliyuncs.com/software/Proxy-SwitchyOmega-Chromium-2.5.15.zip">SwitchyOmega</a></p><p>qv2ray</p><p><a href="https://github.com/springzfx/cgproxy">cgproxy</a>(用来全局proxy)</p><blockquote><p>配置:</p><p>Config file: <strong>/etc/cgproxy/config.json</strong></p><pre class="line-numbers language-none"><code class="language-none">{ "port": 12345, "program_noproxy": ["v2ray", "qv2ray"], "program_proxy": ["/"], "cgroup_noproxy": ["/system.slice/v2ray.service"], "cgroup_proxy": ["/"], "enable_gateway": false, "enable_dns": true, "enable_udp": true, "enable_tcp": true, "enable_ipv4": true, "enable_ipv6": true, "table": 10007, "fwmark": 39283}之后在qv2ray中开启透明代理,DNS拦截,嗅探即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></blockquote><h3 id="通讯软件"><a href="#通讯软件" class="headerlink" title="通讯软件"></a>通讯软件</h3><ol><li>telegram</li><li>qq</li></ol><h3 id="截图软件"><a href="#截图软件" class="headerlink" title="截图软件"></a>截图软件</h3><p>flameshot</p><p>记得在设置中设置他的快捷键</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol><li>google-chrome</li><li>xmind (直接yay就行,<a href="https://myonedex.oss-cn-beijing.aliyuncs.com/software/XMind2020_10.1.1.202003312309_Patch_Linux.zip">pj补丁</a></li><li>typora</li><li>clion  idea vscode </li><li>oh my zsh</li></ol><h2 id="显卡驱动安装-慎重"><a href="#显卡驱动安装-慎重" class="headerlink" title="显卡驱动安装(慎重)"></a>显卡驱动安装(慎重)</h2><p>我的方案可能不适合所有人</p><p>我的配置:</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200805235739178.png"></p><ul><li><p>安装nvidia</p><ul><li><pre><code class="bash">pacman -Ｓ　nvidia</code></pre></li></ul></li><li><p>安装optimus-manager</p></li><li><p>安装optimius-manager-qt</p></li></ul><p>直接下载好的显卡切换管理器图形界面版进行设置即可</p><p>成功切换显卡的标志</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200806000126489.png"></p><h2 id="终结"><a href="#终结" class="headerlink" title="终结"></a>终结</h2><p>一定要做好数据备份,当你折腾Linux的时候有很大可能搞坏他,所以还是想好备份方案,不然重装起来比较麻烦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArchLinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim常见操作</title>
      <link href="2020/08/06/vim-chang-jian-cao-zuo/"/>
      <url>2020/08/06/vim-chang-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h1><h3 id="由normal模式进入insert模式"><a href="#由normal模式进入insert模式" class="headerlink" title="由normal模式进入insert模式"></a>由normal模式进入insert模式</h3><ul><li><code>i</code> 在当前文字前面插入</li><li>a 在当前文字后边插入</li><li>o 在当前行的下一行插入</li><li>I　在当前行前方插入</li><li>A 在当前行后方插入</li><li>O 在当前行上一行插入</li></ul><p>###　vim中的模式</p><table><thead><tr><th align="left">mode</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">insert</td><td align="left">插入模式</td></tr><tr><td align="left">normal</td><td align="left">控制光标的移动</td></tr><tr><td align="left">命令模式</td><td align="left">:命令 进行vim的命令,横竖分屏,查找,替换什么的</td></tr><tr><td align="left">visual</td><td align="left">可视化 进行块状的选择 normal v键进入 使用V选中行 ,ctrl+v 进型方块的操作</td></tr></tbody></table><p>注意:默认情况下是normal模式</p><h3 id="insert模式"><a href="#insert模式" class="headerlink" title="insert模式"></a>insert模式</h3><ul><li>normal模式本质就和普通的编辑器一样</li><li>快捷键<ul><li>CTRL+H 删除上一个字符</li><li>CTRL+W　删除上一个单词</li><li>CTRL+U 删除当前行</li><li>粘贴使用CTRL+V　由于自动设置autoindent 所以缩进会乱掉<ul><li>设置:set paste 此时自动缩进不起作用</li><li>设置 :set nopaste 解决,此时自动缩进起作用</li></ul></li></ul></li></ul><h3 id="command模式"><a href="#command模式" class="headerlink" title="command模式"></a>command模式</h3><ul><li>syntax on 打开语法高亮</li></ul><h3 id="normal模式"><a href="#normal模式" class="headerlink" title="normal模式"></a>normal模式</h3><ul><li>w 跳转到下一个单词开始</li><li>e 跳转到下一个单词结尾</li><li>b 跳转到上一个单词开头</li><li>W　跳转到下一个以空白符分割单词行首</li><li>E 跳转到下一个以空白符分割单词行尾</li><li>B 返回到上一个以空白符分割单词行首</li><li>f{字母} 行间搜索字符,跳转到字符首<ul><li>, 跳转上一个</li><li>; 跳转下一个</li></ul></li><li>t{字母} 行间搜索字符,跳转到字符的前一个单词</li><li>F　字母　反向搜索</li><li>T　字母　反向搜索</li><li>0 移动到行首第一个字符</li><li>^移动到第一个非空白字符 前面不可加数字</li><li>g_ $移动到行尾非空白字符 前面可以加数字</li><li>gg 或者 G　移动到文件的开头和结尾</li><li>CTRL＋O 移动到上一个位置</li><li>H 跳转屏幕开头</li><li>M　跳转屏幕中间</li><li>L 跳转屏幕结尾</li><li>ctrl+u 上翻页</li><li>CTRL+F　下翻页</li><li>zz 将当前行放置在屏幕中间</li><li>dw daw 删除一个单词,包括他周围的空格</li><li>diw 删除一个单词,不包括他周围的空格</li><li>dtx 删除到指定位置,但是不删除x</li><li>d 后边可以拓展好多标记符<ul><li>比如 d0 表示向前删除到行首</li><li>d^表示向后删除到行尾</li></ul></li><li>数字+命令 多次执行此命令<ul><li>3dd 删除三行</li><li>3x 删除三个字母</li><li>3dw 删除三个单词</li></ul></li><li>r(replace) 替换光标处的字母</li><li>s(subtitude) 删除光标处的字母并进入插入模式<ul><li>: 范围 s/搜索的字符/替换的字符/flag 进行替换操作<ul><li>标志位<ul><li>g 表示全局范围内执行</li><li>c 表示确认</li><li>n 报告匹配到的次数,而不进行替换</li><li>e 标记 找不到不是错误</li></ul></li></ul></li></ul></li><li>c(change) 删除当前并进入插入模式,删除的操作和d一样,区别就是进入了插入模式</li><li>R 不断替换后面的字符</li><li>S 删除整行并进入插入模式</li><li>/单词 向下查找</li><li>?单词 向上查找</li><li>n跳转到下一个,N跳转到上一个</li><li>dd 删除一行</li><li>x 删除一个字符</li><li>y 复制</li><li>p 粘贴</li><li>t 剪贴</li><li>y同样是一个命令,可以搭配文本对象来用</li><li>yy 复制一行</li></ul><h3 id="visual模式"><a href="#visual模式" class="headerlink" title="visual模式"></a>visual模式</h3><ul><li>v 选中移动的东西</li><li>V 选中行</li><li>CTRL+V　选中矩形</li><li>选中之后　按　ｄ　或　ｘ　可将选中的东西删除</li><li>“&gt;” 命令把选中的文档向右移动一个 “平移单位”，中间用空白填充。平移的起始点是可<br>视列块的左边界。</li><li>“&lt;” 命令向左移动一个 “平移单位”</li></ul><p>###　多文件操作</p><ul><li>使用:ls 列出当前缓冲区,用:b n 跳转到第n个缓冲区</li><li>:bpre :bnext :bfirst :blast 进行缓冲区的跳转</li><li>b 文件名 跳转到指定的文件</li><li>:sp 水平分割<ul><li>CTRL+W　切换到下一个窗口</li></ul></li><li>:vs 垂直分割</li><li>:close 退出窗口.防止在退出时推出了vim</li><li>:only 关闭其他窗口</li><li>:split 2.cpp 打开其他窗口</li><li>CTRL+W + 扩大窗口 这只是缩放</li><li>CRTL＋W - 缩胸啊窗口</li><li>4split 使得多开的窗口只有4行</li><li>CTRL+W＋移动符 移动到相应的位置</li><li>命令行界面:vimdiff 1.cpp 2.cpp 比较两文件的不同 zo 打开折叠 zc 关闭折叠</li><li>:vertical diffsplit main.c~ 在分割窗口的条件下比较两文件的不同</li><li>:set noscrollbind 取消鼠标滚动时两窗口同步滚动</li><li>]c 跳转到下一个修改点</li><li>]c跳转到上一个修改点</li><li>:diffupdate 更新修改后的差异比较</li><li>:3read filename 将指定文件内容添加进入指定范围的后面</li><li>:3write filename 将指定文件的3行保存</li></ul><h3 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h3><ul><li>w 单词</li><li>p 段落</li><li>s 句子</li><li>次数 命令 文本对象</li></ul><p>###　寄存器的操作</p><p>删除的东西保存到无名寄存器中，粘贴也是从无名寄存器中选取</p><p>“寄存器名称 来指定寄存器</p><p>+号代表系统剪切板</p><p>:set clipboard=unnamed 设置可以从系统剪贴板复制粘贴</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>q寄存器录制 q停止</li><li>q 寄存器选择保存的寄存器</li><li>@寄存器 回放宏</li></ul><h3 id="补全"><a href="#补全" class="headerlink" title="补全"></a>补全</h3><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200304163607240.png" alt="image-20200304163607240"></p><p><strong>image-20200304163607240</strong></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200304165323662.png" alt="image-20200304165323662"></p><p><strong>image-20200304165323662</strong></p><h3 id="配置和插件"><a href="#配置和插件" class="headerlink" title="配置和插件"></a>配置和插件</h3><ul><li>就是vimrc的配置文件</li></ul><p>###　vim的映射</p><ul><li>就是自定义的那些按键</li><li>unmap可以取消映射</li><li>vmap表示可视化模式下的操作</li><li>\ 代表的是大写</li><li>注意按键的冲突形成递归映射</li><li>非递归映射<ul><li>noremap</li><li>vnoremap</li><li>inoremap</li></ul></li><li>最好使用非递归映射</li></ul><h3 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h3><ul><li>插件搜索<ul><li>谷歌搜索 用英文<ul><li>vim plug</li></ul></li></ul></li><li>vimawesome网站标记 含义<br>按退出键<br>按回车键，也写作<br>按控制键<br>按制表键<br>按切换键<br>同时按 和<br>按上光标键<br>按下光标键<br>␣ 按空格键</li><li>vim -u NONE -N 在启动时不启动vimrc</li></ul><h3 id="技巧1"><a href="#技巧1" class="headerlink" title="技巧1"></a>技巧1</h3><ul><li>. 重复执行上一次的操作</li><li>“&gt;” 两个空格</li></ul><p>###　技巧２</p><p>###　通过文档发现的指令</p><ul><li>ZZ 保存并退出</li><li>zz 将当前行移动到屏幕中央</li><li>:e! 重载原来的文件进行编辑</li><li>% 进行括号匹配</li><li>50 % 代表移动到文件中间</li><li>Ctrl+U　Ctrl＋D　向上或者下滚动半屏</li><li>Ctrl＋F　CTRL＋B 向上或者向下滚动全屏</li><li>zt zb 当前光标所在行移动到屏幕顶部或者底部</li><li>set ignorecase 忽略大小写的打开和关闭</li><li>&gt;“ 是一个特殊的记号，表示只匹配单词末尾。类似地，”&lt;“ 只匹配单词的开头</li><li>:set incsearch 一边输入,一边匹配</li><li>crtl+ o 跳转到较老的地方 ctrl+i 跳转到较新的地方</li><li>m26个字母 标记当前位置</li><li>‘标记位置 移动到标记的位置</li><li>~ 改变大小写</li><li>set wildmenu 设置自动补全</li><li>syntax on 打开语法高亮</li><li>set autowrite 自动保存文件</li><li>set backup 设置备份文件</li><li>set backupnext=xx 设置自己喜欢的备份文件名称</li><li>“fy 拷贝 “fp 粘贴</li><li>:write&gt;&gt;文件名 以追加的方式导入文件中</li><li>vim -R　file　以只读的方式打开一个文件 但是在:w 后面添加一个!还是会被接受</li><li>vim -M　file　打开文件时是只读的，但是限制仍然可以被解除<ul><li>:set modifiable :set write 解除保护</li></ul></li><li>:set textwidth=72 每行72个单词自动换行.如果只是在行中间输入或删除一些东西,这个功能就无效了</li><li>gq 文本对象 表示文本对象之间的分隔符为空行</li><li>g CTRL+G　统计字数</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim容易忘记的命令</title>
      <link href="2020/08/06/vim-shi-yong/"/>
      <url>2020/08/06/vim-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="vim容易忘记的命令"><a href="#vim容易忘记的命令" class="headerlink" title="vim容易忘记的命令"></a>vim容易忘记的命令</h1><p>bash</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">f  行间搜索  ，是上一个  ；是下一个t  行间搜索   跳转到的搜索到字母的前一个字符Ctrl+U  向上翻半页Ctrl+D  向下翻半页Ctrl+F  向下一页Ctrl+B  向上一页Ｒ　替换后边的内容，并直接开始写r   替换一个单词c　删除后边的文本对象，并进入插入模式C  删除一行，进入插入模式qh 使用寄存器h录制操作@q 回放录制的东西u 撤销Ctrl+U 回退mf 用寄存器m做一个标记‘f 返回这个标记Ctrl+O 跳转到较为老的地方Ctrl+n 跳转到较为新的地方<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo配合腾讯cos搭建博客</title>
      <link href="2020/08/06/hexo-pei-he-teng-xun-cos-da-jian-bo-ke/"/>
      <url>2020/08/06/hexo-pei-he-teng-xun-cos-da-jian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="腾讯cos配合cdn搭建hexo静态博客"><a href="#腾讯cos配合cdn搭建hexo静态博客" class="headerlink" title="腾讯cos配合cdn搭建hexo静态博客"></a>腾讯cos配合cdn搭建hexo静态博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次只用的是腾讯云cos存储+他的cdn国内加速</p><p>为什么要用cdn？</p><p>cdn可以实现用自己域名绑定cos给出的链接之后，用https的方式访问博客</p><p>hk 的bucket延迟较高</p><p>为什么要选择hk的cos？</p><p>因为hk的bucket不需要冗长的备案</p><h2 id="套餐的选择"><a href="#套餐的选择" class="headerlink" title="套餐的选择"></a>套餐的选择</h2><table><thead><tr><th align="left">cos地区</th><th align="left">cdn加速范围</th><th align="left">价格</th></tr></thead><tbody><tr><td align="left">hk</td><td align="left">国内</td><td align="left"></td></tr><tr><td align="left">ap-beijing</td><td align="left">国内</td><td align="left"></td></tr></tbody></table><h2 id="更好的搭配方案"><a href="#更好的搭配方案" class="headerlink" title="更好的搭配方案"></a>更好的搭配方案</h2><p>beijing的bucket+国内cdn 供国内访问</p><p>githubpage+国外的cdn 供国外访问</p><p>总的来说就是实现双线部署，一次提交两份博客</p><h2 id="方法记录"><a href="#方法记录" class="headerlink" title="方法记录"></a>方法记录</h2><h3 id="hexo本地的操作"><a href="#hexo本地的操作" class="headerlink" title="hexo本地的操作"></a>hexo本地的操作</h3><h4 id="安装脚本并修改配置文件"><a href="#安装脚本并修改配置文件" class="headerlink" title="安装脚本并修改配置文件"></a>安装脚本并修改配置文件</h4><p>进入hexo项目目录下执行以下命令安装一键部署脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-qcloud-cos --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再到hexo项目配置文件中配置以下参数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:    type: qcloud-cos    cosRegion: <span class="token operator">&lt;</span>您的cos bucket所在区域代码<span class="token operator">&gt;</span>    cosSecretId: <span class="token operator">&lt;</span>您的cos accessKeyId<span class="token operator">&gt;</span>    cosSecretKey: <span class="token operator">&lt;</span>您的cos accessKeySecret<span class="token operator">&gt;</span>    cosBucket: <span class="token operator">&lt;</span>您的cos bucket名称<span class="token operator">&gt;</span>    cosAppid:  <span class="token operator">&lt;</span>您的腾讯云账户appid<span class="token operator">&gt;</span>    remotePath: <span class="token operator">&lt;</span>您要部署的目录,默认为根目录,默认无需设置<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="腾讯云界面的操作"><a href="#腾讯云界面的操作" class="headerlink" title="腾讯云界面的操作"></a>腾讯云界面的操作</h3><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><p>首先我们需要在腾讯云控制台获取下列所需的配置参数：</p><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">APPID</td><td align="left">开发者访问 COS 服务时拥有的用户维度唯一资源标识，用以标识资源</td></tr><tr><td align="left">SecretId</td><td align="left">开发者拥有的项目身份识别 ID，用以身份认证</td></tr><tr><td align="left">SecretKey</td><td align="left">开发者拥有的项目身份密钥</td></tr><tr><td align="left">Bucket</td><td align="left">COS 中用于存储数据的容器名称</td></tr><tr><td align="left">Region</td><td align="left">Bucket所在的地域信息。</td></tr></tbody></table><h5 id="获取APPID"><a href="#获取APPID" class="headerlink" title="获取APPID"></a>获取APPID</h5><p>访问腾讯云控制台 点击右上角用户名 &gt; 账户信息 可以查看到APPID，写入</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630185250.png" alt="img"></p><p><img src="http://image.werty.cn/blog20190630185617.png" alt="img"></p><h5 id="获取SecretId和SecretKey"><a href="#获取SecretId和SecretKey" class="headerlink" title="获取SecretId和SecretKey"></a>获取SecretId和SecretKey</h5><p>点击控制台右上角用户名 &gt; <a href="https://console.cloud.tencent.com/cam/overview">访问管理</a></p><p>说明：此处为遵循云服务安全最佳实践，使用角色创建用户。如果图一时方便，可以直接使用访问管理页面的【访问密钥】&gt; 【API密钥管理】创建密钥后使用，该密钥拥有控制您腾讯云账户所有资源的能力，强烈建议不要这么做！</p><p><img src="http://image.werty.cn/blog20190630225838.png" alt="img"></p><p>进入后点击用户 &gt; 新建用户</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630191646.png" alt="img"></p><p>选择自定义创建</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630192253.png" alt="img"></p><p>输入用户名称，访问方式仅勾选编程访问，点击下一步</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630192519.png" alt="img"></p><p>在策略搜索框中输入<code>QcloudCOSFullAccess</code> 搜索后勾选该策略，点击下一步</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630192747.png" alt="img"></p><p>确认信息无误后点击完成</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630192815.png" alt="img"></p><p>记录该页面中的SecretId和SecretKey，写入配置文件_config.yml 中</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630193024.png" alt="img"></p><h5 id="获取bucket和region"><a href="#获取bucket和region" class="headerlink" title="获取bucket和region"></a>获取bucket和region</h5><p>首先从<a href="https://cloud.tencent.com/document/product/436/6224">腾讯云可用地域代码</a> 中选择距离自己较近或者自己喜欢的区域，记录区域代码和区域名称</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630193806.png" alt="img"></p><p>bucket是我们创建的对象存储的空间名称，这里我们有两种方式可以创建bucket</p><ul><li><p>方法1 使用 <code>hexo-deployer-qcloud-cos</code>插件自动创建</p><p>将我们想要创建的bucket名称写入配置文件，然后执行hexo 部署命令 （<a href="https://hexo.io/zh-cn/docs/deployment">部署命令参考文档</a>）</p><pre class="line-numbers language-none"><code class="language-none">hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署工具在部署前会检测bucket是否存在，如果不存在，会在命令行中出现自动创建bucket确认，如图，输入y确认创建</p></li><li><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630200338.png" alt="img"></p><p>创建成功后，将出现是否立即部署命令，输入y可立即部署，此处我们直接立即部署，便于后续测试</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630210530.png" alt="img"></p><p>注意：bucket名称在cos所有区域是唯一的</p></li><li><p>方法2 使用腾讯云控制台手动创建</p><p>使用腾讯云控制台手动创建bucket的流程此处不再演示，大家可以参照官方文档 <a href="https://cloud.tencent.com/document/product/436/13309">创建存储桶</a></p><p>注意：</p><ul><li><strong>用于部署静态网站的bucket访问权限必须设为public-read 即公共读！</strong>否则即使设置对象文件权限为公开，仍将会导致COS静态网站的索引文档功能失效</li><li>控制台创建的存储桶名称格式为-格式，如<code>newbucket-125000000</code>在设置配置文件时，bucket只需要输入-前面的部分即可</li></ul></li></ul><h3 id="修改存储桶bucket设置"><a href="#修改存储桶bucket设置" class="headerlink" title="修改存储桶bucket设置"></a>修改存储桶bucket设置</h3><h4 id="开启静态网站设置"><a href="#开启静态网站设置" class="headerlink" title="开启静态网站设置"></a>开启静态网站设置</h4><p>进入控制台<a href="https://console.cloud.tencent.com/cos5/bucket">对象存储管理页面</a><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630201936.png" alt="img"></p><p>点击刚刚创建的存储桶名称，进入存储桶详情页面，点击基础配置</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630211032.png" alt="img"></p><p>页面滑到底部，找到静态网站栏目，开启静态网站，索引文档设置为<code>index.html</code></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630225729.png" alt="img"></p><h4 id="设置自定义域名"><a href="#设置自定义域名" class="headerlink" title="设置自定义域名"></a>设置自定义域名</h4><p>点击存储桶详情页面的域名管理选项卡，在自定义源站域名栏目下点击添加域名，源站类型选择【静态网站源站】，在域名位置输入博客要解析的域名，点击保存，复制CNAME值，到域名服务商处设置解析，此处需要设置的域名必须时已经备案过的域名，若域名尚未备案，则不能设置。（如果是hk的bucket，不需要备案，不过最好还是备案下，不然之后的cdn无法进行国内加速）</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/blog20190630222456.png" alt="img"></p><h3 id="开启cdn加速，并实现全站https"><a href="#开启cdn加速，并实现全站https" class="headerlink" title="开启cdn加速，并实现全站https"></a>开启cdn加速，并实现全站https</h3><p>CDN 加速适用于对 COS 存储桶中的内容进行下载、分发，特别是对于相同内容反复下载的使用场景。<br>用户可对以下域名进行管理，实现存储桶中对象的快速下载和分发：</p><ul><li>默认域名：即 COS 源站域名，是创建存储桶时，由系统根据存储桶名称和地域自动生成的，要与默认加速域名区分开。</li><li>默认加速域名：经由 CDN 加速节点的域名，系统默认生成，用户可选择开启或关闭。</li><li>自定义域名：用户可以为存储桶绑定已备案的自定义域名，通过自定义域名访问存储桶中的对象。</li></ul><h4 id="默认加速域名操作步骤："><a href="#默认加速域名操作步骤：" class="headerlink" title="默认加速域名操作步骤："></a>默认加速域名操作步骤：</h4><p>单击存储桶详情界面上方的<strong>域名管理</strong>，单击<strong>编辑</strong>，把默认加速域名的当前状态设置为开启。源站类型通常默认为 XML 节点，如果作为源站的存储桶开启了静态网站，并且希望为静态网站加速，则选择为静态网站节点。（<strong>此处因为我布置的hexo的静态博客，因此需要勾选静态网站节点</strong>）<br>当存储桶为公有读时，则不需要开启 回源鉴权，最后单击【保存】按钮即可开启 CDN 加速。<br><a href="https://image-1253170309.cos.ap-guangzhou.myqcloud.com/image/COSGithub%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1hexo5.png"><img src="https://image-1253170309.cos.ap-guangzhou.myqcloud.com/image/COSGithub%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1hexo5.png" alt="img"></a><br>注意：<br>如果用户在之前从未使用过腾讯云 CDN 服务，则无法进入<strong>域名管理</strong>，需先进入 CDN 控制台使用 CDN 服务。</p><h4 id="自定义加速域名操作步骤："><a href="#自定义加速域名操作步骤：" class="headerlink" title="自定义加速域名操作步骤："></a>自定义加速域名操作步骤：</h4><p>进入<strong>域名管理</strong>页面，在第二栏“自定义加速域名”处单击<strong>添加域名</strong>，输入待绑定的自定义域名，如ww w.example.com，回源鉴权可不开启，单击右侧的<strong>保存</strong>即可完成域名添加。</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200711155825009.png" alt="image-20200711155825009"></p><p>注意:用户为域名启用 CDN 加速之后，任何人都可以通过此域名直接访问源站，所以如果您的数据有一定的私密性，请您务必通过 鉴权配置 来保护您的源站数据。</p><hr><h4 id="自定义域名添加DNS解析"><a href="#自定义域名添加DNS解析" class="headerlink" title="自定义域名添加DNS解析"></a>自定义域名添加DNS解析</h4><p>当把上一步域名绑定储存桶和CDN加速域名完成之后，就可以开始优化DNS解析了。（默认域名无须添加解析）<br>到你的域名解析页面，添加上两条解析。</p><p><a href="https://image-1253170309.cos.ap-guangzhou.myqcloud.com/image/COSGithub%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1hexo7.jpg"><img src="https://image-1253170309.cos.ap-guangzhou.myqcloud.com/image/COSGithub%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1hexo7.jpg" alt="img"></a></p><hr><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><a href="http://tool.chinaz.com/dns/">DNS查询</a>：选择CNAME类型，看响应ip是否为添加解析的记录值</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200711160052923.png" alt="image-20200711160052923"></p><h4 id="https设置（如果没有这方面需求可忽略这一步）"><a href="#https设置（如果没有这方面需求可忽略这一步）" class="headerlink" title="https设置（如果没有这方面需求可忽略这一步）"></a>https设置（如果没有这方面需求可忽略这一步）</h4><p>进入到配置证书的界面</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200711160352361.png" alt="image-20200711160352361"></p><p>根据提示添加证书信息</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200711160519561.png" alt="image-20200711160519561"></p><p>证书可以使用腾讯或者阿里提供的免费证书，下载ngix那个版本的就好（实在不知道怎么填写的参考<a href="https://cloud.tencent.com/document/product/228/41686">这里</a>)</p><p>回源协议勾选HTTPS就好</p><p>最后访问你的域名，看看有没有那把小锁</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200711160944589.png" alt="image-20200711160944589"></p><p>至此，使用腾讯cos建站并使用cdn实现https 已经结束</p><h2 id="参考的资料"><a href="#参考的资料" class="headerlink" title="参考的资料"></a>参考的资料</h2><p><a href="https://blog.yleao.com/2018/0802/%E8%85%BE%E8%AE%AF%E4%BA%91COS-CDN-Github%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1hexo.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E6%B7%BB%E5%8A%A0DNS%E8%A7%A3%E6%9E%90">blog.yleao</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> vps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp面向过程</title>
      <link href="2020/08/06/cpp-mian-xiang-guo-cheng/"/>
      <url>2020/08/06/cpp-mian-xiang-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="面向过程的一些基础"><a href="#面向过程的一些基础" class="headerlink" title="面向过程的一些基础"></a>面向过程的一些基础</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>理解&gt;&gt; 和&lt;&lt;运算符的本质</p><p>cin&gt;&gt;a; cin是istream类的一个对象,从流中读取一段,并赋值给后方</p><p>cin当做条件时,当流中没有数据 代表条件为假(istream类的对象都可这么用)</p><p>同理cout也是ostream类的一个对象,对象就是object,按照这样理解比较方便</p><p>这本书里的对象意思是<strong>具某种类型的一段内存空间</strong></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200723173914158.png" alt="img"></p><p>几个注意点:</p><ol><li>最好使用double,因为float和double的运算时间差不多,但是double的精度还更大</li><li>一个int至少和一个short一样大、一个long至少和一个int一样大、一个long long至少和一个long一样大</li><li><strong>因为short通常太小，而long一般和int一样大，所以，若超过了int的尺寸，就用long long</strong></li></ol><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><p>转义序列</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200723180745121.png" alt="img"></p><p>指定字面值的类型</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/clip_image003-1590767084328.png" alt="img"></p><p>true和false是布尔类型字面值常量</p><p>nullptr是指针类型字面值常量</p><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><h3 id="辨析声明-定义-初始化-赋值"><a href="#辨析声明-定义-初始化-赋值" class="headerlink" title="辨析声明 定义 初始化 赋值"></a>辨析声明 定义 初始化 赋值</h3><table><thead><tr><th align="left">名词</th><th align="left">含义</th><th align="left">辨析</th></tr></thead><tbody><tr><td align="left">声明</td><td align="left">在内存中开辟一块空间 int a;</td><td align="left">和定义类似</td></tr><tr><td align="left">定义</td><td align="left">在内存中开辟一块空间 int a;</td><td align="left">和声明类似</td></tr><tr><td align="left">初始化</td><td align="left">创建变量时就赋予给他一个初始值 int a=1; 在开辟空间的时候顺便给他了一个值</td><td align="left"></td></tr><tr><td align="left">赋值</td><td align="left">把当前变量的值擦除,写入新的值 a=3; 擦除存储空间的那个值,重新给了他一个值</td><td align="left"></td></tr></tbody></table><p>声明使得名字被程序所知,变量可以被声明很多次,但是不能被定义很多次</p><p>external int a; 就是声明a</p><p>当原本的变量定义为全局变量时,才可以在声明处,使用这个变量的定义</p><p><strong>定义</strong>在块状区域内的变量,即使他和块状区域外面某个变量重名,但是,还是以块状区域内定义的为标准,要访问块状区域外边的变量时使用作用域解析符</p><p>当然,大块状区域的有效范围高于大块状之内的小块状的有效范围</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>定义变量的时候没有给他一个值</p><p>就是声明和定义</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200723182956080.png" alt="img"></p><p>对于类的对象创建时的初始化问题,有的类要求对象显示初始化,有的不要求初始化</p><p>string 类没有初始化时,默认值是0</p><h3 id="初始化的方式"><a href="#初始化的方式" class="headerlink" title="初始化的方式"></a>初始化的方式</h3><p>推广使用列表初始化</p><p>就是{ } 这样</p><p>基本内置类型不适合列表初始化</p><h3 id="变量的名称规范"><a href="#变量的名称规范" class="headerlink" title="变量的名称规范"></a>变量的名称规范</h3><ul><li>标识符由数字、字母、下划线组成。必须以字母或者下划线开头</li><li>标识符不可用内置的标识符，且不能连续出现两个下划线</li><li>不能以下划线紧连大写字母开头</li><li>定义在函数体外的标识符不能以下划线开头</li><li>变量名称不能是C++关键字</li></ul><p>C++ 关键字</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200723221943274.png" alt="img"></p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>组成:<strong>基本数据类型+声明符</strong></p><p>平时的int a; a就是变量名列表,同样属于声明符</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通常说的是左值引用,相当于给变量起了另一个名称,他并不是对象</p><p>因此,引用定义时必须初始化,只能绑定在对象上,不能绑定在字面值或者计算结果上</p><blockquote><p>引用可以指向指针,这是阅读声明从右往左读很轻松的</p></blockquote><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针本身就是一个对象,他里边存放着另一个对象的内存地址(因此指针的值就是他指向对象的内存空间的地址)</p><p>指针只能指向对象,因此他不能指向引用(引用没有地址)</p><blockquote><p>void* 类型指针</p><p>这个类型的指针能容纳一切地址,但是无法知道地址那里的数据是什么类型(即不能使用解引用符号来探查他指向内存空间的值)</p></blockquote><blockquote><p>指向指针的指针</p><p>可以让一个指针指向另一个指针,只需让声明符使用两次就行</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>c<span class="token operator">=</span><span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>作用:为了限定某个对象的值,防止其他人无意之间修改</p><p>const对象必须初始化</p><blockquote><p>默认状态下，const对象仅在文件内有效，编译器会在编译的过程中把用到该变量的地方换为相对应的值<br>当多个文件中定义了同名const时，相当与在多个文件中定义了独立的变量</p></blockquote><h4 id="共享const的方法"><a href="#共享const的方法" class="headerlink" title="共享const的方法:"></a>共享const的方法:</h4><blockquote><p>当出现一个const变量(只有初始值不是常量的时候才这么做,是常量的时候直接extern就行)，初始值不是常量表达式，但是又要在文件间共享，需要在每个文件中使用extern const int a=func();</p></blockquote><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>常量指针:指针本身是一个常量(因为指针是一个对象).</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//同样从右往左看,p是个常量,他的类型是指针,所以他只是常量那么简单</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">//p是个指针,是个对象,前面const限定了他指向的东西不能通过他来改变(没有规定不能从其他突进改变)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724175635681.png" alt="img"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724181111643.png" alt="img"></p><h4 id="顶层const和底层const的对比"><a href="#顶层const和底层const的对比" class="headerlink" title="顶层const和底层const的对比"></a>顶层const和底层const的对比</h4><p>就指针类型来说</p><table><thead><tr><th align="left"></th><th align="left">哪一层const</th><th align="left">指向的对象是否可变</th><th align="left">可否通过自己来改变指向对象的值</th></tr></thead><tbody><tr><td align="left">const int *p=&amp;a;</td><td align="left">底层const</td><td align="left">可以</td><td align="left">不可以</td></tr><tr><td align="left">int * const p=&amp;a;</td><td align="left">顶层const</td><td align="left">不可以(因为这个指针是常量)</td><td align="left">看情况</td></tr></tbody></table><h4 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h4><p>可以显示的将变量声明为constexpr来告诉编译器表达式是常量</p><p>constexpr int mf=20;</p><p>如果你认为一个变量是常量表达式，就将他声明为constexpr</p><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>auto一般会忽略顶层const，保留底层const</p><p>一般在auto前显示加const保留顶层const</p><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span> <span class="token punctuation">(</span>fun<span class="token operator">/</span>name<span class="token punctuation">)</span> var <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>decltype 顶层和顶层const都会识别</p><p>推断含有const的变量时，定义的变量必须赋值</p><p>decltype(( i )) x; x类型为int &amp; 双层括号的结果必为引用</p><h3 id="字符串-向量和数组"><a href="#字符串-向量和数组" class="headerlink" title="字符串 向量和数组"></a>字符串 向量和数组</h3><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> abc <span class="token punctuation">{</span>    <span class="token comment">//在里边定义各种内容即可</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>头文件不应该包含using声明,因为,如果 某个头文件如果包含了这个头文件,可能发生不经意间的名字冲突错误</p></blockquote><h4 id="string类库"><a href="#string类库" class="headerlink" title="string类库"></a>string类库</h4><h5 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h5><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724190911873.png" alt="img"></p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724191016933.png" alt="img"></p><p>is指的是输入流对象,像cin什么的</p><p>空string连\0也没有</p><h5 id="判定库"><a href="#判定库" class="headerlink" title="判定库"></a>判定库</h5><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724191545111.png" alt="img"></p><p>适合处理string中的每一个字符,使用给予范围的for循环处理更方便</p><p>for(auto &amp;c:str){</p><p>}</p><p>使用引用,可以直接修改字符串中的值</p><h4 id="vector-类库"><a href="#vector-类库" class="headerlink" title="vector 类库"></a>vector 类库</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724192147903.png" alt="img"></p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724192307081.png" alt="img"></p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>和指针唯一区别就是获取地址不需要取值运算符,其余操作完全一样</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>定义数组的时候要制定好类型，不能用auto关键词推断类型</li><li>不允许拷贝赋值</li><li>理解的时候得按照<strong>从内向外阅读</strong></li><li>默认的情况下，类型修饰符从右向左依次绑定</li></ul><p>声明的解读:</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>point<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>point是一个指针,指向一个含有10个元素的数组,数组元素的类型是int</p><p>标准库函数 begin() 和end() 直接获取数组的首指针和尾后指针</p><h5 id="用数组初始化vector"><a href="#用数组初始化vector" class="headerlink" title="用数组初始化vector"></a>用数组初始化vector</h5><p>vector name (begin(arry),end(arry));</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>当赋值给无符号数一个超过他表示的类型的数的时候，结果是无符号数的总数—超过他范围的那个数</li><li>当从无符号数中减去一个值的时候，不管这个数是不是无符号数，我们都应该确保最后的结果不是一个负数</li><li>赋值给无符号数一个超过他表示范围的值的时候,结果是初始值对无符号类型表示数值总数取模后的余数</li></ul><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>c++ 先将两种类型的值统一类型后再进行值的相加</p><p>发生隐式类型转换的情形</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724231805378.png" alt="image-20200724231805378"></p><p><strong>image-20200724231805378</strong></p><p>其他隐式转换情形:</p><ol><li>数组名自动转换为数组首部元素的指针</li></ol><h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>有时不得不用强制类型转换,但是这样做是非常危险的</p><p>命名的强制类型转换:</p><p>通用格式:</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cast<span class="token operator">-</span>name<span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>cast<span class="token operator">-</span>name是强制转换的类型type是要转换的类型value是需要转换的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下是几种cast_name</p><h5 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h5><p>适用于将大类型转换为小类型,比如double转换为float,此时编译器不会发出警告信息</p><p><strong>对于编译器无法自动执行的类型转换也很有用</strong>(比如找回void* 中指针的值)</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>        <span class="token keyword">auto</span> voidp<span class="token operator">=</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>voidp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>只能改变运算对象的底层const(即可以用底层const给非顶层const赋值)</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>c<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>temp<span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>temp<span class="token punctuation">;</span><span class="token operator">*</span>temp<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>temp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时就可以用temp指针改变a的值</p><h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p>通常为运算对象的位模式提高比较底层上的重新解释</p><p>p145</p><p>最后,应该避免强制类型转换</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>表达式是有一个或者多个运算对象组成,对表达式求值将得到一个结果</p><p>字面值和变量是最简单的表达式</p><p>表达式加个分号就是语句</p></blockquote><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>当一个对象被用作右值时,用的是对象的值(内容),当对象被用作左值时,用到的是他的对象的身份(在内存中的位置)</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724201336084.png" alt="img"></p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>检查和设置二进制位</p><p>书本138页,现在觉得没啥用,以后用到再总结</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724235607672.png" alt="img"></p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200724235641507.png" alt="img"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字</p><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><blockquote><p>引用传递</p><p>如果函数无需改变引用形参的值,将他声明为常量引用</p></blockquote><blockquote><p>按值传递</p><p>因为拷贝大的对象或容器的时候比较低效，甚至有的对象根本不支持拷贝操作</p><p>如果函数无需改变引用形参的值，最好声明为常量引用</p></blockquote><blockquote><p>const形参和实参</p><p>p192</p></blockquote><blockquote><p>传递数组</p><p>通常传递首指针和尾后指针</p></blockquote><blockquote><p>含有可变形参的函数</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200725133205212.png" alt="img"></p><p>这其实就是一个模板传递同种类型的参数,和vector类似,只是不能修改该对象中的值</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200725133506311.png" alt="img"></p><p>调用的时候,参数列表必须在{ } 内使用</p></blockquote><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字具有作用域,对象拥有生命周期</p><p>局部变量的生命周期依赖于定义的方式</p><p>局部静态对象:生命周期存在于整个程序运行过程</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>与初始化变量的方式一样，返回的值用于初始化调用点的一个临时量</li><li>若函数返回一个引用，则该引用仅是他所引用对象的一个别名</li></ul><p><strong>不要返回局部对象的指针或者引用</strong> 因为这样做不安全,在函数体执行完毕后,引用的东西可能会被释放</p><p>调用一个返回引用的函数得到左值,其他的返回类型都是右值</p><p>可以返回一个列表,但是必须用{ } 方式返回,返回值类型是vector就可以</p><blockquote><p>返回一个数组</p><p>使用</p><p>cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//返回一个指向十个整形元素的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种声明方式可以更好理解函数返回值类型</p></blockquote><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>顶层const和没有顶层const 的形参区分不开</p><p>重载情形:</p><blockquote><p>重载那些非常相似的操作</p></blockquote><p>重载的选择:</p><p>对于那种参数个数相同,且类型可以相互转换的情形</p><p><img src="https://typoraup.oss-cn-beijing.aliyuncs.com/img/image-20200725141329548.png" alt="img"></p><p><strong>函数匹配用到再看吧,现在看了估计也用不出来</strong></p><p>p219</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针指向的是函数</p><p><strong>函数名就是函数的地址</strong> (取值运算符可有可无)</p><p>函数类型就是去掉函数名的那一部分</p><p>函数指针不用解引用就能访问函数</p><p>用decltype推断函数时,返回的函数类型,不是指向函数的指针,要用指针,加上*即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
